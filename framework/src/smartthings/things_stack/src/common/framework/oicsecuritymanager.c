#include <stdlib.h>
#include <unistd.h>
#include <ifaddrs.h>
#include <netpacket/packet.h>

#ifdef _SVR_ENC_
#ifdef OCF_RTOS
#include "sss_storage_server.h"
#else
#include "ssAPI.h"
#include "ssDevice.h"
#endif
#endif
#include "securevirtualresourcetypes.h"

//Added as workround to test cert based (D)TLS connection
#include "srmresourcestrings.h"

#include "thingslogger.h"
#include "thingsmalloc.h"
#include "oicsecuritymanager.h"
#include "oiccommon.h"
#include "credresource.h"
#include "ssSha2.h"
#include "oxmverifycommon.h"
#include "oic_string.h"
#include "utlist.h"
#include "aclresource.h"
#include "srmutility.h"

#include "wifi_utils.h"

#if defined(CONFIG_TLS_WITH_SSS) && defined(CONFIG_HW_ECDSA)
#if defined(CONFIG_IOTIVITY_SSS_STORAGE) // pkss
#ifndef USE_SSS
 #define USE_SSS
#endif
#endif // pkss
#endif



#define TAG "OIC_SEC_MGR"

typedef enum {
    OIC_SEC_OK = 0,
    OIC_SEC_ERROR = 1,
    OIC_SEC_INVALID_PARAM = 2
}OICSecurityResult;

#if __MIPS__
    #define STRING_SVR_DB_PATH "/data1/oic_svr_db_server.dat"
#elif __TIZEN__
    #define STRING_SVR_DB_PATH "/opt/data/ocfData/oic_svr_db_server.dat"
#else
    #define STRING_SVR_DB_PATH "./oic_svr_db_server.dat"
#endif

#define MD_MAX_LEN 64
#define MAC_BUF_SIZE 64
#define MAX_PATH_LEN 100

static char SVR_DB_PATH[MAX_PATH_LEN] = {0};

static OICAuthType_t                gAuthType = AUTH_JUST_WORKS;
static bool gIsSvrDbExist = false;
static bool gIsMfgCertRequired = false;
#ifdef OCF_RTOS
#define USER_CONFIRM 1
#define SetVerifyOption(x) {}
#define sync() {}
#endif
const unsigned char OIC_SVR_DB_COMMON[] = {
    0xBF, 0x63, 0x61, 0x63, 0x6C, 0x59, 0x03, 0x2B, 0xA4, 0x66, 0x61, 0x63, 0x6C, 0x69, 0x73, 0x74,
    0xA1, 0x64, 0x61, 0x63, 0x65, 0x73, 0x84, 0xA3, 0x6B, 0x73, 0x75, 0x62, 0x6A, 0x65, 0x63, 0x74,
    0x75, 0x75, 0x69, 0x64, 0x61, 0x2A, 0x69, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x83, 0xA4, 0x64, 0x68, 0x72, 0x65, 0x66, 0x68, 0x2F, 0x6F, 0x69, 0x63, 0x2F, 0x72, 0x65, 0x73,
    0x62, 0x72, 0x74, 0x81, 0x6A, 0x6F, 0x69, 0x63, 0x2E, 0x77, 0x6B, 0x2E, 0x72, 0x65, 0x73, 0x62,
    0x69, 0x66, 0x81, 0x69, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x6C, 0x6C, 0x63, 0x72, 0x65,
    0x6C, 0x60, 0xA4, 0x64, 0x68, 0x72, 0x65, 0x66, 0x66, 0x2F, 0x6F, 0x69, 0x63, 0x2F, 0x64, 0x62,
    0x72, 0x74, 0x81, 0x68, 0x6F, 0x69, 0x63, 0x2E, 0x77, 0x6B, 0x2E, 0x64, 0x62, 0x69, 0x66, 0x82,
    0x6F, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x62, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65,
    0x68, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x72, 0x63, 0x72, 0x65, 0x6C, 0x60, 0xA4, 0x64,
    0x68, 0x72, 0x65, 0x66, 0x66, 0x2F, 0x6F, 0x69, 0x63, 0x2F, 0x70, 0x62, 0x72, 0x74, 0x81, 0x68,
    0x6F, 0x69, 0x63, 0x2E, 0x77, 0x6B, 0x2E, 0x70, 0x62, 0x69, 0x66, 0x82, 0x6F, 0x6F, 0x69, 0x63,
    0x2E, 0x69, 0x66, 0x2E, 0x62, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x68, 0x6F, 0x69, 0x63,
    0x2E, 0x69, 0x66, 0x2E, 0x72, 0x63, 0x72, 0x65, 0x6C, 0x60, 0x6A, 0x70, 0x65, 0x72, 0x6D, 0x69,
    0x73, 0x73, 0x69, 0x6F, 0x6E, 0x02, 0xA3, 0x6B, 0x73, 0x75, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x75,
    0x75, 0x69, 0x64, 0x61, 0x2A, 0x69, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x73, 0x84,
    0xA4, 0x64, 0x68, 0x72, 0x65, 0x66, 0x6D, 0x2F, 0x6F, 0x69, 0x63, 0x2F, 0x73, 0x65, 0x63, 0x2F,
    0x64, 0x6F, 0x78, 0x6D, 0x62, 0x72, 0x74, 0x81, 0x6A, 0x6F, 0x69, 0x63, 0x2E, 0x72, 0x2E, 0x64,
    0x6F, 0x78, 0x6D, 0x62, 0x69, 0x66, 0x81, 0x6F, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x62,
    0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x63, 0x72, 0x65, 0x6C, 0x60, 0xA4, 0x64, 0x68, 0x72,
    0x65, 0x66, 0x6E, 0x2F, 0x6F, 0x69, 0x63, 0x2F, 0x73, 0x65, 0x63, 0x2F, 0x70, 0x73, 0x74, 0x61,
    0x74, 0x62, 0x72, 0x74, 0x81, 0x6B, 0x6F, 0x69, 0x63, 0x2E, 0x72, 0x2E, 0x70, 0x73, 0x74, 0x61,
    0x74, 0x62, 0x69, 0x66, 0x81, 0x6F, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x62, 0x61, 0x73,
    0x65, 0x6C, 0x69, 0x6E, 0x65, 0x63, 0x72, 0x65, 0x6C, 0x60, 0xA4, 0x64, 0x68, 0x72, 0x65, 0x66,
    0x6C, 0x2F, 0x6F, 0x69, 0x63, 0x2F, 0x73, 0x65, 0x63, 0x2F, 0x61, 0x63, 0x6C, 0x62, 0x72, 0x74,
    0x81, 0x69, 0x6F, 0x69, 0x63, 0x2E, 0x72, 0x2E, 0x61, 0x63, 0x6C, 0x62, 0x69, 0x66, 0x81, 0x6F,
    0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x62, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x63,
    0x72, 0x65, 0x6C, 0x60, 0xA4, 0x64, 0x68, 0x72, 0x65, 0x66, 0x6D, 0x2F, 0x6F, 0x69, 0x63, 0x2F,
    0x73, 0x65, 0x63, 0x2F, 0x63, 0x72, 0x65, 0x64, 0x62, 0x72, 0x74, 0x81, 0x6A, 0x6F, 0x69, 0x63,
    0x2E, 0x72, 0x2E, 0x63, 0x72, 0x65, 0x64, 0x62, 0x69, 0x66, 0x81, 0x6F, 0x6F, 0x69, 0x63, 0x2E,
    0x69, 0x66, 0x2E, 0x62, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x63, 0x72, 0x65, 0x6C, 0x60,
    0x6A, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x06, 0xA3, 0x6B, 0x73, 0x75,
    0x62, 0x6A, 0x65, 0x63, 0x74, 0x75, 0x75, 0x69, 0x64, 0x61, 0x2A, 0x69, 0x72, 0x65, 0x73, 0x6F,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x81, 0xA3, 0x64, 0x68, 0x72, 0x65, 0x66, 0x75, 0x2F, 0x73, 0x65,
    0x63, 0x2F, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x69, 0x6E, 0x67, 0x69, 0x6E,
    0x66, 0x6F, 0x62, 0x72, 0x74, 0x81, 0x78, 0x1E, 0x78, 0x2E, 0x63, 0x6F, 0x6D, 0x2E, 0x73, 0x61,
    0x6D, 0x73, 0x75, 0x6E, 0x67, 0x2E, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x69,
    0x6E, 0x67, 0x69, 0x6E, 0x66, 0x6F, 0x62, 0x69, 0x66, 0x81, 0x68, 0x6F, 0x69, 0x63, 0x2E, 0x69,
    0x66, 0x2E, 0x61, 0x6A, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x07, 0xA3,
    0x6B, 0x73, 0x75, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x75, 0x75, 0x69, 0x64, 0x61, 0x2A, 0x69, 0x72,
    0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x73, 0x81, 0xA3, 0x64, 0x68, 0x72, 0x65, 0x66, 0x74,
    0x2F, 0x73, 0x65, 0x63, 0x2F, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x70, 0x6F, 0x69, 0x6E, 0x74,
    0x6C, 0x69, 0x73, 0x74, 0x62, 0x72, 0x74, 0x81, 0x78, 0x1D, 0x78, 0x2E, 0x63, 0x6F, 0x6D, 0x2E,
    0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x2E, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x70, 0x6F,
    0x69, 0x6E, 0x74, 0x6C, 0x69, 0x73, 0x74, 0x62, 0x69, 0x66, 0x81, 0x68, 0x6F, 0x69, 0x63, 0x2E,
    0x69, 0x66, 0x2E, 0x73, 0x6A, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x02,
    0x6A, 0x72, 0x6F, 0x77, 0x6E, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D,
    0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x62, 0x72, 0x74, 0x81, 0x69, 0x6F, 0x69, 0x63, 0x2E, 0x72, 0x2E, 0x61, 0x63, 0x6C, 0x62,
    0x69, 0x66, 0x81, 0x6F, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x62, 0x61, 0x73, 0x65, 0x6C,
    0x69, 0x6E, 0x65, 0x65, 0x70, 0x73, 0x74, 0x61, 0x74, 0x58, 0x9D, 0xA9, 0x64, 0x69, 0x73, 0x6F,
    0x70, 0xF4, 0x62, 0x63, 0x6D, 0x02, 0x62, 0x74, 0x6D, 0x00, 0x62, 0x6F, 0x6D, 0x04, 0x62, 0x73,
    0x6D, 0x04, 0x6A, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30,
    0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x6A, 0x72, 0x6F, 0x77, 0x6E, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30,
    0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x62, 0x72, 0x74, 0x81, 0x6B, 0x6F, 0x69, 0x63, 0x2E, 0x72, 0x2E, 0x70,
    0x73, 0x74, 0x61, 0x74, 0x62, 0x69, 0x66, 0x81, 0x6F, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E,
    0x62, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x64, 0x64, 0x6F, 0x78, 0x6D, 0x58
};

//, 0xD9 + oxm array size /*length of doxm header + length of doxm payload */,
#define DOXM_PAYLOAD_SIZE (0xD4)

const unsigned char OIC_SVR_DB_DOXM_HEADER[] = {
    0xBF, 0x64, 0x6F, 0x78, 0x6D, 0x73
};

//0x80 + oxm array size /*oxm size*/,
#define DOXM_OXM_SIZE (0x80)

// 0x00, 0x01, 0x02 : oxm value as array

const unsigned char OIC_SVR_DB_DOXM_PAYLOAD[] = {
    0x66, 0x6F, 0x78, 0x6D, 0x73, 0x65, 0x6C, 0x00, 0x63, 0x73, 0x63, 0x74, 0x01, 0x65, 0x6F, 0x77,
    0x6E, 0x65, 0x64, 0xF4, 0x6A, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x75, 0x75, 0x69, 0x64, 0x78,
    0x24, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30,
    0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, /*0x63, 0x6D, 0x6F, 0x6D, 0x01, */ /*"mom":1*/ 0x6C, 0x64, 0x65, 0x76, 0x6F, 0x77,
    0x6E, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30,
    0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x6A, 0x72, 0x6F,
    0x77, 0x6E, 0x65, 0x72, 0x75, 0x75, 0x69, 0x64, 0x78, 0x24, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30, 0x30, 0x30,
    0x30, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x62, 0x72,
    0x74, 0x81, 0x6A, 0x6F, 0x69, 0x63, 0x2E, 0x72, 0x2E, 0x64, 0x6F, 0x78, 0x6D, 0x62, 0x69, 0x66,
    0x81, 0x6F, 0x6F, 0x69, 0x63, 0x2E, 0x69, 0x66, 0x2E, 0x62, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E,
    0x65, 0xFF, 0xFF
};

//static FILE* server_fopen(const char *path, const char *mode)
#ifdef _SVR_ENC_
FILE* server_secure_fopen(const char *path, const char *mode)
{
    THINGS_LOG_D(THINGS_DEBUG,TAG,"SVR DB File Path : %s", SVR_DB_PATH);
    (void)path;
    return secure_fopen(SVR_DB_PATH, mode);
}
#else

FILE* server_fopen(const char *path, const char *mode) // pkss
{
    THINGS_LOG_D(THINGS_DEBUG,TAG,"F SVR DB File Path : %s", SVR_DB_PATH);
    (void)path;
    return fopen(SVR_DB_PATH, mode);
}

size_t server_fread(FAR void *ptr, size_t size, size_t n_items, FAR FILE *stream)
{
	struct timeval start, end;
	size_t ret = 0;
	gettimeofday(&start, NULL);
	ret = fread(ptr, size, n_items, stream);
	gettimeofday(&end, NULL);
	return ret;
}

size_t server_fwrite(FAR const void *ptr, size_t size, size_t n_items, FAR FILE *stream)
{
	struct timeval start, end;
	size_t ret = 0;
	gettimeofday(&start, NULL);

	ret = fwrite(ptr, size, n_items, stream);

	gettimeofday(&end, NULL);
	return ret;
}

int server_fclose(FILE *stream)
{
	int ret = fclose(stream);
	return ret;
}
// ~pkss
#endif

/*
 * This API Setup Seckey from filepath
 */
static OCStackResult SeckeySetup(const char* fileName, OicSecKey_t* key, OicEncodingType_t encoding)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN: %s", __func__);

    size_t size = 0;
    key->data = NULL;
    key->len = 0;
    key->encoding = OIC_ENCODING_UNKNOW;
    FILE* fp = fopen(fileName, "rb");

    if (fp == NULL) {
        THINGS_LOG_D(THINGS_ERROR, TAG, "Can not open file[%s].", fileName);
        THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT[FAIL]: %s", __func__);
        return OC_STACK_ERROR;
    }

    if( 0 == fseek(fp, 0L, SEEK_END) )
    {
        size = ftell(fp);
        rewind(fp);
        key->data = (uint8_t *)DAMalloc(size);
        if (key->data == NULL) {
            THINGS_LOG_D(THINGS_ERROR, TAG, "Memory Full");
            THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT[FAIL]: %s", __func__);
            return OC_STACK_NO_MEMORY;
        }
        fread(key->data, 1, size, fp);
        key->len = size;
        key->encoding = encoding;
    }

    THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT: %s", __func__);
    return OC_STACK_OK;
}

/*
 * This API added as workaround to test certificate based (D)TLS connection.
 * It will be replaced to use TZ or eSE based key protection.
 */
static OCStackResult SaveSignedAsymmetricKey(OicUuid_t* subjectUuid);

static int GenerateSvrDb()
{
    THINGS_LOG_D(THINGS_INFO, TAG, "In %s", __func__);

    if(AUTH_UNKNOW == gAuthType)
    {
        THINGS_LOG(THINGS_INFO, TAG, "Unknown authentication type for ownership transfer.");
        THINGS_LOG(THINGS_INFO, TAG, "please make sure your configuration in ocf_info.json.");
        THINGS_LOG(THINGS_INFO, TAG, "----------------------");
        THINGS_LOG(THINGS_INFO, TAG, "Justwork authentication will be used as default authentication method.");
        THINGS_LOG(THINGS_INFO, TAG, "----------------------");
        gAuthType = AUTH_JUST_WORKS;
    }

    FILE *fp = NULL;

#ifdef _SVR_ENC_
    fp=secure_fopen(SVR_DB_PATH, "w");
#else
     fp=fopen(SVR_DB_PATH, "w");
#endif

    OICSecurityResult res = OIC_SEC_ERROR;

    if ( NULL != fp )
    {
        int idx = 0;
        unsigned char* svrDB = NULL;
        unsigned char* curPos = NULL;
        //To generate OxM Array.
        uint16_t oxms[OIC_OXM_COUNT + 3 /*Number of vendor specific OxM*/] = {0};
        size_t oxmCnt = 0;
        size_t oxmSize = 0;
        size_t svrDBSize = 0;

        if( gAuthType & AUTH_JUST_WORKS )
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Justworks OxM.");
            oxms[oxmCnt++] = OIC_JUST_WORKS;
            oxmSize++;
        }
        if( gAuthType & AUTH_RANDOM_PIN)
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Random PIN based OxM.");
            oxms[oxmCnt++] = OIC_RANDOM_DEVICE_PIN;
            oxmSize++;
        }
        if( gAuthType & AUTH_CERTIFICATE || gAuthType & AUTH_CERTIFICATE_CONFIRM)
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Certificate based OxM.");
            oxms[oxmCnt++] = OIC_MANUFACTURER_CERTIFICATE;
            oxmSize++;
        }
        if( gAuthType & AUTH_DECENTRALIZED_PUB_KEY)
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Decentralized public key based OxM.");
            oxms[oxmCnt++] = OIC_DECENTRALIZED_PUBLIC_KEY;
            oxmSize++;
        }
        if( gAuthType & AUTH_PRECONF_PIN)
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Preconfigured-PIN based OxM (for MOT only).");
            oxms[oxmCnt++] = 0xFF00; //OIC_PRECONFIG_PIN
            oxmSize+=3;
        }
        if( gAuthType & AUTH_JUST_WORKS_MUTUAL_VERIFIED)
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Mutual Verification Justworks based OxM.");
            oxms[oxmCnt++] = 0xFF01;
            oxmSize+=3;
        }
        if( gAuthType & AUTH_CERTIFICATE || gAuthType & AUTH_CERTIFICATE_CONFIRM)
        {
            THINGS_LOG(THINGS_DEBUG, TAG, "Added Certificate+Confirm based OxM.");
            oxms[oxmCnt++] = 0xFF02;
            oxmSize+=3;
        }
        if(0 == oxmCnt)
        {
            THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Failed to extract authentication types.");
            THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Please make sure your configuration in ocf_info.json.");
            res = OIC_SEC_INVALID_PARAM;
            goto error;
        }

        svrDBSize = sizeof(OIC_SVR_DB_COMMON) +
                    sizeof(OIC_SVR_DB_DOXM_HEADER) +
                    sizeof(OIC_SVR_DB_DOXM_PAYLOAD) +
                    2/*size of payload length*/ + oxmSize;
        svrDB = (unsigned char*)DAMalloc(svrDBSize + 32);
        if(NULL == svrDB)
        {
            THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Failed to memory allocation.");
            goto error;
        }

        //
        //Generate default SVR DB
        curPos = svrDB;

        //Construct Common part of SVR DB
        memcpy(curPos, OIC_SVR_DB_COMMON, sizeof(OIC_SVR_DB_COMMON));
        curPos += sizeof(OIC_SVR_DB_COMMON);

        //Construct Doxm payload size
        *curPos = (unsigned char)(DOXM_PAYLOAD_SIZE + oxmSize);
        curPos++;

        //Construct Doxm Header
        memcpy(curPos, OIC_SVR_DB_DOXM_HEADER, sizeof(OIC_SVR_DB_DOXM_HEADER));
        curPos += sizeof(OIC_SVR_DB_DOXM_HEADER);


        //Construct Length of OxM array
        *curPos = (unsigned char)(DOXM_OXM_SIZE + oxmCnt);
        curPos++;

        //Construct OxM array
        for(idx = 0; idx < oxmCnt; idx++)
        {
            if(oxms[idx] < OIC_OXM_COUNT)
            {
                *curPos = oxms[idx];
                curPos++;
            }
            else if(oxms[idx] == 0xFF00)
            {
                *curPos = 0x19;
                curPos++;
                *curPos = 0xFF;
                curPos++;
                *curPos = 0x00;
                curPos++;
            }
            else if(oxms[idx] == 0xFF01)
            {
                *curPos = 0x19;
                curPos++;
                *curPos = 0xFF;
                curPos++;
                *curPos = 0x01;
                curPos++;
            }
            else if(oxms[idx] == 0xFF02)
            {
                *curPos = 0x19;
                curPos++;
                *curPos = 0xFF;
                curPos++;
                *curPos = 0x02;
                curPos++;
            }
        }

        //Construct Doxm payload
        memcpy(curPos, OIC_SVR_DB_DOXM_PAYLOAD, sizeof(OIC_SVR_DB_DOXM_PAYLOAD));

        //End of default SVR DB generation
        //

        //Save the constructed SVR DB into persistent storage.
#ifdef _SVR_ENC_
        secure_fwrite(svrDB, 1, svrDBSize, fp);
        secure_fclose(fp);
#else
        fwrite(svrDB, 1, svrDBSize, fp);
        fclose(fp);
#endif
        DAFree(svrDB);
        THINGS_LOG_D(THINGS_INFO, TAG, "Out %s", __func__);
        return OIC_SEC_OK;
error:
#ifdef _SVR_ENC_
        secure_fclose(fp);
#else
        fclose(fp);
#endif
        DAFree(svrDB);
        return OIC_SEC_ERROR;
    }
    else
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Can not open the [%s], Please make sure the access permision of file system.", SVR_DB_PATH);
    }

    return res;  // return 0 when failed, 1 otherwise..
}

static int GetMacAddr(unsigned char* pIdBuf, size_t pIdBufSize, unsigned int* pIdOutLen)
{
    char macAddr[MAC_BUF_SIZE];
    struct ifaddrs *ifaddr=NULL;
    struct ifaddrs *ifa = NULL;
    int family = 0;
    int i = 0;

    THINGS_LOG_D(THINGS_DEBUG, TAG, "In %s", __func__);

#ifdef OCF_RTOS
    wifi_utils_info stWifiInfo;
    wifi_utils_get_info(&stWifiInfo);

    if(wifi_utils_get_info(&stWifiInfo)!=WIFI_UTILS_SUCCESS)
    {
    	 THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,"MAC Get Error\n");
    	return OIC_SEC_ERROR;
    }

    snprintf((char*)pIdBuf , MAC_BUF_SIZE-1, "%02X%02X%02X%02X%02X%02X", stWifiInfo.mac_address[0], stWifiInfo.mac_address[1], stWifiInfo.mac_address[2], stWifiInfo.mac_address[3], stWifiInfo.mac_address[4], stWifiInfo.mac_address[5]);
#else
    if (getifaddrs(&ifaddr) == -1)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Failed to read network address information.");
        return OIC_SEC_ERROR;
    }
    else
    {
        for ( ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next)
        {
            if ( (ifa->ifa_addr) && (ifa->ifa_addr->sa_family == AF_PACKET) )
            {
                struct sockaddr_ll *s = (struct sockaddr_ll*)ifa->ifa_addr;

                memset(pIdBuf, 0x00, pIdBufSize);
                for (i=0; i < s->sll_halen && i < pIdBufSize; i++)
                {
                    snprintf((char*)(pIdBuf + (i * 2)), MAC_BUF_SIZE - i, "%02X", (s->sll_addr[i]));
                }
            }
        }
        freeifaddrs(ifaddr);
    }
#endif
    THINGS_LOG_D(THINGS_DEBUG, TAG, "MAC Address : %s", (char*)pIdBuf);
    *pIdOutLen = strlen((char*)pIdBuf);

    THINGS_LOG_D(THINGS_DEBUG, TAG, "Out %s", __func__);

    return OIC_SEC_OK;
}

// /**
//  * Added by Jay to support Mutual verifiation based Just-works.
//  */
// OCStackResult GetUserConfirmation(void * ctx)
// {
//     OCStackResult ret = OC_STACK_USER_DENIED_REQ;

//     if(gUserConfirmCB)
//     {
//         int result = gUserConfirmCB();

//         switch(result)
//         {
//             case 1:
//             {
//                 THINGS_LOG_V(THINGS_INFO, TAG, "User Confirmed~!!");
//                 ret = OC_STACK_OK;
//                 break;
//             }
//             default:
//             {
//                 THINGS_LOG_V_ERROR(THINGS_ERROR, TAG, "User Denied~!! : [ %d ]", result);
//                 break;
//             }
//         }
//     }

//     return ret;
// }


//
// ++ Added by Chul Lee : To support MAC based UUID
int SM_GenerateMacBasedDeviceId(bool isForced)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "In %s", __func__);

//#ifdef USE_SSS // pkss
	//InitializeSSSKeyHandlers();
//#endif

    if(gIsSvrDbExist && !isForced)
    {
        THINGS_LOG_D(THINGS_WARNING, TAG, "MAC based device UUID generation is not required.");
        return OIC_SEC_OK;
    }

    OICSecurityResult res = OIC_SEC_ERROR;
    OicUuid_t deviceId;
    unsigned char macId[MAC_BUF_SIZE];
    unsigned char hashValue[SS_SHA256_DIGEST_SIZE + 1];
    unsigned int idLen = 0;

    res = GetMacAddr(macId, MAC_BUF_SIZE, &idLen);
    if(OIC_SEC_OK != res)
    {
        THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Failed to read MAC Address.");
        return res;
    }
    THINGS_LOG_V(THINGS_INFO, TAG, "MAC Address : %s", macId);

    ss_sha256_ctx sha256Ctx;
    ss_sha256_init(&sha256Ctx);
    ss_sha256_update(&sha256Ctx, macId, idLen);
    ss_sha256_final(&sha256Ctx, hashValue);

    memcpy(deviceId.id, hashValue, sizeof(deviceId.id));

    OCStackResult ocRes = SetDoxmDeviceID(&deviceId);
    if(OC_STACK_OK != ocRes)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Error in SetDoxmDeviceID : %d", (int)ocRes);
        return OIC_SEC_ERROR;
    }

    // Added as workaround for cert based D2D & D2S connection
    ocRes = SaveSignedAsymmetricKey(&deviceId);
    if(OC_STACK_OK != ocRes)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Error in SaveSignedAsymmetricKey : %d", (int)ocRes);
        return OIC_SEC_ERROR;
    }

    THINGS_LOG_D(THINGS_DEBUG, TAG, "Out %s", __func__);

    return res;
}
// ++ Added by Chul Lee : To support MAC based UUID
//


int SM_InitOICSecurity(int authType, const char* dbPath)
{
    OICSecurityResult res = OIC_SEC_ERROR;

    THINGS_LOG_D(THINGS_DEBUG, TAG, "In %s", __func__);

    memset(SVR_DB_PATH, 0x00, MAX_PATH_LEN);

    if(dbPath != NULL
	   && strlen(dbPath) > 0 )
    {
        DAStrncpy(SVR_DB_PATH, dbPath, MAX_PATH_LEN);
    }
    else
    {
        THINGS_LOG_ERROR(THINGS_ERROR,TAG,"DB Path Not Inserted. Using Default Value");
        DAStrncpy(SVR_DB_PATH, STRING_SVR_DB_PATH, MAX_PATH_LEN);
    }

    THINGS_LOG_D(THINGS_DEBUG,TAG,"SVR DB PATH : %s", SVR_DB_PATH);

    gAuthType = authType;
    if( (gAuthType & AUTH_JUST_WORKS_MUTUAL_VERIFIED) ||
        (gAuthType & AUTH_CERTIFICATE_CONFIRM))
    {
        SetVerifyOption(USER_CONFIRM);
    }

    gIsMfgCertRequired = false;
    if( (gAuthType & AUTH_CERTIFICATE) ||
        (gAuthType & AUTH_CERTIFICATE_CONFIRM))
    {
        gIsMfgCertRequired = true;
    }

#ifdef _SVR_ENC_
//    ssSetDeviceUniqueIDCallback(&GetMacAddr);
#endif
    res = SM_InitSvrDb();
    if(OIC_SEC_OK != res)
    {
        THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Failed to create SVR DB.");
        return res;
    }

#ifdef _SVR_ENC_
	static OCPersistentStorage ps = {server_secure_fopen,
									 secure_fread,
									 secure_fwrite,
									 secure_fclose,
									 unlink};
#ifndef OCF_RTOS
	if (SS_SUCCESS != InitSecureStorage())
	{
		THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "InitSecureStorage error!");
		return OIC_SEC_ERROR;
	}
#endif
#else
//	static OCPersistentStorage ps = {server_fopen, fread, fwrite, fclose, unlink};
	static OCPersistentStorage ps = {server_fopen, server_fread, server_fwrite, server_fclose, unlink};
	THINGS_LOG(THINGS_INFO, TAG, "******* WARNING : SVR DB will be used without encryption *******");
#endif

	OCStackResult ocRes = OCRegisterPersistentStorageHandler(&ps);
    if (OC_STACK_INCONSISTENT_DB == ocRes || OC_STACK_SVR_DB_NOT_EXIST == ocRes)
    {
        //If failed to load SVR DB
        THINGS_LOG_D(THINGS_WARNING, TAG, "SVR DB[%s] is inconsistent or not exist : %d", SVR_DB_PATH, ocRes);
        THINGS_LOG_D(THINGS_WARNING, TAG, "SVR DB will be reinstalled as default SVR DB.");

        //Remove previous SVR DB, if exist.
        int removeRet = secure_remove(SVR_DB_PATH);
        if (0 != removeRet)
        {
            THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Failed to remove [%s] : %d", SVR_DB_PATH, removeRet);
            return OIC_SEC_ERROR;
        }

        //re-generate and re-install SVR DB
        gIsSvrDbExist = false;
        res = SM_InitSvrDb();
        if(OIC_SEC_OK != res)
        {
            THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Failed to create SVR DB.");
            return res;
        }

        //Re-register PSI
        ocRes = OCRegisterPersistentStorageHandler(&ps);
        if(OC_STACK_OK != ocRes)
        {
            THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Failed to register persistent storage for SVR DB : %d", (int)ocRes);
            return OIC_SEC_ERROR;
        }
    }
    else if(OC_STACK_OK != ocRes)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Failed to register persistent storage for SVR DB : %d", (int)ocRes);
        return OIC_SEC_ERROR;
	}

    THINGS_LOG_D(THINGS_DEBUG, TAG, "Out %s", __func__);

    return OIC_SEC_OK;
}

void SM_TerminateOICSecurity()
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "In %s", __func__);
#ifdef _SVR_ENC_
#ifndef OCF_RTOS
    if (SS_SUCCESS != DeinitSecureStorage())
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "DeinitSecureStorage error!");
    }
#endif
#endif
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Out %s", __func__);
}

int SM_InitSvrDb()
{
#ifdef _SVR_ENC_
    FILE *fp = secure_fopen(SVR_DB_PATH, "r");
#else
    FILE *fp = fopen(SVR_DB_PATH, "r");
#endif
    if ( fp == NULL )
    {
        THINGS_LOG_D(THINGS_INFO, TAG, "Can not find the [%s], SVR DB will be automatically generated...", SVR_DB_PATH);
        THINGS_LOG_D(THINGS_INFO, TAG, "Out %s", __func__);
        return GenerateSvrDb();
    }
    else
    {
         THINGS_LOG_D(THINGS_INFO, TAG, "SVR DB [%s] is already exist.", SVR_DB_PATH);
        gIsSvrDbExist = true;
    }

#ifdef _SVR_ENC_
    secure_fclose(fp);
#else
    fclose(fp);
#endif
    THINGS_LOG_D(THINGS_INFO, TAG, "Out %s", __func__);

    return OIC_SEC_OK;
}

int SM_ResetSvrDb()
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "In %s", __func__);
    OCStackResult ocRes = ResetSecureResourceInPS();
    if(OC_STACK_OK != ocRes)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "ResetSecureResourceInPS error : %d", ocRes);
        return OIC_SEC_ERROR;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Out %s", __func__);
    return OIC_SEC_OK;
}


//
// ++ Added by Chul Lee : to test certificate based (D)TLS connection for  D2D & D2S

#ifndef _EXCLUDE_TEST_KEY_
static OicSecKey_t primaryCert;
static OicSecKey_t primaryKey;
// static OicSecKey_t mfgPrimaryCert;
// static OicSecKey_t mfgPrimaryKey;
#endif //_EXCLUDE_TEST_KEY_

//thawte_Primary_Root_CA.der
const unsigned char gGlobalCIRootCa[] = {
    0x30, 0x82, 0x04, 0x20, 0x30, 0x82, 0x03, 0x08, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x34, 0x4E, 0xD5, 0x57, 0x20,
    0xD5, 0xED, 0xEC, 0x49, 0xF4, 0x2F, 0xCE, 0x37, 0xDB, 0x2B, 0x6D, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0xA9, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
    0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C,
    0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1F, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x44,
    0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x2F, 0x28, 0x63,
    0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20,
    0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65,
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x74, 0x68, 0x61, 0x77,
    0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1E,
    0x17, 0x0D, 0x30, 0x36, 0x31, 0x31, 0x31, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x33, 0x36, 0x30,
    0x37, 0x31, 0x36, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xA9, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55,
    0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61,
    0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1F,
    0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
    0x65, 0x73, 0x20, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x2F, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49,
    0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64,
    0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16,
    0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20,
    0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05,
    0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xAC, 0xA0, 0xF0, 0xFB, 0x80,
    0x59, 0xD4, 0x9C, 0xC7, 0xA4, 0xCF, 0x9D, 0xA1, 0x59, 0x73, 0x09, 0x10, 0x45, 0x0C, 0x0D, 0x2C, 0x6E, 0x68, 0xF1, 0x6C,
    0x5B, 0x48, 0x68, 0x49, 0x59, 0x37, 0xFC, 0x0B, 0x33, 0x19, 0xC2, 0x77, 0x7F, 0xCC, 0x10, 0x2D, 0x95, 0x34, 0x1C, 0xE6,
    0xEB, 0x4D, 0x09, 0xA7, 0x1C, 0xD2, 0xB8, 0xC9, 0x97, 0x36, 0x02, 0xB7, 0x89, 0xD4, 0x24, 0x5F, 0x06, 0xC0, 0xCC, 0x44,
    0x94, 0x94, 0x8D, 0x02, 0x62, 0x6F, 0xEB, 0x5A, 0xDD, 0x11, 0x8D, 0x28, 0x9A, 0x5C, 0x84, 0x90, 0x10, 0x7A, 0x0D, 0xBD,
    0x74, 0x66, 0x2F, 0x6A, 0x38, 0xA0, 0xE2, 0xD5, 0x54, 0x44, 0xEB, 0x1D, 0x07, 0x9F, 0x07, 0xBA, 0x6F, 0xEE, 0xE9, 0xFD,
    0x4E, 0x0B, 0x29, 0xF5, 0x3E, 0x84, 0xA0, 0x01, 0xF1, 0x9C, 0xAB, 0xF8, 0x1C, 0x7E, 0x89, 0xA4, 0xE8, 0xA1, 0xD8, 0x71,
    0x65, 0x0D, 0xA3, 0x51, 0x7B, 0xEE, 0xBC, 0xD2, 0x22, 0x60, 0x0D, 0xB9, 0x5B, 0x9D, 0xDF, 0xBA, 0xFC, 0x51, 0x5B, 0x0B,
    0xAF, 0x98, 0xB2, 0xE9, 0x2E, 0xE9, 0x04, 0xE8, 0x62, 0x87, 0xDE, 0x2B, 0xC8, 0xD7, 0x4E, 0xC1, 0x4C, 0x64, 0x1E, 0xDD,
    0xCF, 0x87, 0x58, 0xBA, 0x4A, 0x4F, 0xCA, 0x68, 0x07, 0x1D, 0x1C, 0x9D, 0x4A, 0xC6, 0xD5, 0x2F, 0x91, 0xCC, 0x7C, 0x71,
    0x72, 0x1C, 0xC5, 0xC0, 0x67, 0xEB, 0x32, 0xFD, 0xC9, 0x92, 0x5C, 0x94, 0xDA, 0x85, 0xC0, 0x9B, 0xBF, 0x53, 0x7D, 0x2B,
    0x09, 0xF4, 0x8C, 0x9D, 0x91, 0x1F, 0x97, 0x6A, 0x52, 0xCB, 0xDE, 0x09, 0x36, 0xA4, 0x77, 0xD8, 0x7B, 0x87, 0x50, 0x44,
    0xD5, 0x3E, 0x6E, 0x29, 0x69, 0xFB, 0x39, 0x49, 0x26, 0x1E, 0x09, 0xA5, 0x80, 0x7B, 0x40, 0x2D, 0xEB, 0xE8, 0x27, 0x85,
    0xC9, 0xFE, 0x61, 0xFD, 0x7E, 0xE6, 0x7C, 0x97, 0x1D, 0xD5, 0x9D, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x42, 0x30, 0x40,
    0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06,
    0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E,
    0x04, 0x16, 0x04, 0x14, 0x7B, 0x5B, 0x45, 0xCF, 0xAF, 0xCE, 0xCB, 0x7A, 0xFD, 0x31, 0x92, 0x1A, 0x6A, 0xB6, 0xF3, 0x46,
    0xEB, 0x57, 0x48, 0x50, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
    0x82, 0x01, 0x01, 0x00, 0x79, 0x11, 0xC0, 0x4B, 0xB3, 0x91, 0xB6, 0xFC, 0xF0, 0xE9, 0x67, 0xD4, 0x0D, 0x6E, 0x45, 0xBE,
    0x55, 0xE8, 0x93, 0xD2, 0xCE, 0x03, 0x3F, 0xED, 0xDA, 0x25, 0xB0, 0x1D, 0x57, 0xCB, 0x1E, 0x3A, 0x76, 0xA0, 0x4C, 0xEC,
    0x50, 0x76, 0xE8, 0x64, 0x72, 0x0C, 0xA4, 0xA9, 0xF1, 0xB8, 0x8B, 0xD6, 0xD6, 0x87, 0x84, 0xBB, 0x32, 0xE5, 0x41, 0x11,
    0xC0, 0x77, 0xD9, 0xB3, 0x60, 0x9D, 0xEB, 0x1B, 0xD5, 0xD1, 0x6E, 0x44, 0x44, 0xA9, 0xA6, 0x01, 0xEC, 0x55, 0x62, 0x1D,
    0x77, 0xB8, 0x5C, 0x8E, 0x48, 0x49, 0x7C, 0x9C, 0x3B, 0x57, 0x11, 0xAC, 0xAD, 0x73, 0x37, 0x8E, 0x2F, 0x78, 0x5C, 0x90,
    0x68, 0x47, 0xD9, 0x60, 0x60, 0xE6, 0xFC, 0x07, 0x3D, 0x22, 0x20, 0x17, 0xC4, 0xF7, 0x16, 0xE9, 0xC4, 0xD8, 0x72, 0xF9,
    0xC8, 0x73, 0x7C, 0xDF, 0x16, 0x2F, 0x15, 0xA9, 0x3E, 0xFD, 0x6A, 0x27, 0xB6, 0xA1, 0xEB, 0x5A, 0xBA, 0x98, 0x1F, 0xD5,
    0xE3, 0x4D, 0x64, 0x0A, 0x9D, 0x13, 0xC8, 0x61, 0xBA, 0xF5, 0x39, 0x1C, 0x87, 0xBA, 0xB8, 0xBD, 0x7B, 0x22, 0x7F, 0xF6,
    0xFE, 0xAC, 0x40, 0x79, 0xE5, 0xAC, 0x10, 0x6F, 0x3D, 0x8F, 0x1B, 0x79, 0x76, 0x8B, 0xC4, 0x37, 0xB3, 0x21, 0x18, 0x84,
    0xE5, 0x36, 0x00, 0xEB, 0x63, 0x20, 0x99, 0xB9, 0xE9, 0xFE, 0x33, 0x04, 0xBB, 0x41, 0xC8, 0xC1, 0x02, 0xF9, 0x44, 0x63,
    0x20, 0x9E, 0x81, 0xCE, 0x42, 0xD3, 0xD6, 0x3F, 0x2C, 0x76, 0xD3, 0x63, 0x9C, 0x59, 0xDD, 0x8F, 0xA6, 0xE1, 0x0E, 0xA0,
    0x2E, 0x41, 0xF7, 0x2E, 0x95, 0x47, 0xCF, 0xBC, 0xFD, 0x33, 0xF3, 0xF6, 0x0B, 0x61, 0x7E, 0x7E, 0x91, 0x2B, 0x81, 0x47,
    0xC2, 0x27, 0x30, 0xEE, 0xA7, 0x10, 0x5D, 0x37, 0x8F, 0x5C, 0x39, 0x2B, 0xE4, 0x04, 0xF0, 0x7B, 0x8D, 0x56, 0x8C, 0x68
};

//thawte_Primary_Root_CA-G2_ECC.der
const unsigned char gGlobalCIRootCa_G2[] = {
    0x30, 0x82, 0x02, 0x88, 0x30, 0x82, 0x02, 0x0D, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x35, 0xFC, 0x26, 0x5C, 0xD9,
    0x84, 0x4F, 0xC9, 0x3D, 0x26, 0x3D, 0x57, 0x9B, 0xAE, 0xD7, 0x56, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
    0x04, 0x03, 0x03, 0x30, 0x81, 0x84, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E,
    0x63, 0x2E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x2F, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30,
    0x37, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72,
    0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79,
    0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1B, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x50, 0x72,
    0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x1E,
    0x17, 0x0D, 0x30, 0x37, 0x31, 0x31, 0x30, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x33, 0x38, 0x30,
    0x31, 0x31, 0x38, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0x84, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55,
    0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61,
    0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x2F,
    0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x37, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63,
    0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1B, 0x74, 0x68,
    0x61, 0x77, 0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41,
    0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x76, 0x30, 0x10, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x05,
    0x2B, 0x81, 0x04, 0x00, 0x22, 0x03, 0x62, 0x00, 0x04, 0xA2, 0xD5, 0x9C, 0x82, 0x7B, 0x95, 0x9D, 0xF1, 0x52, 0x78, 0x87,
    0xFE, 0x8A, 0x16, 0xBF, 0x05, 0xE6, 0xDF, 0xA3, 0x02, 0x4F, 0x0D, 0x07, 0xC6, 0x00, 0x51, 0xBA, 0x0C, 0x02, 0x52, 0x2D,
    0x22, 0xA4, 0x42, 0x39, 0xC4, 0xFE, 0x8F, 0xEA, 0xC9, 0xC1, 0xBE, 0xD4, 0x4D, 0xFF, 0x9F, 0x7A, 0x9E, 0xE2, 0xB1, 0x7C,
    0x9A, 0xAD, 0xA7, 0x86, 0x09, 0x73, 0x87, 0xD1, 0xE7, 0x9A, 0xE3, 0x7A, 0xA5, 0xAA, 0x6E, 0xFB, 0xBA, 0xB3, 0x70, 0xC0,
    0x67, 0x88, 0xA2, 0x35, 0xD4, 0xA3, 0x9A, 0xB1, 0xFD, 0xAD, 0xC2, 0xEF, 0x31, 0xFA, 0xA8, 0xB9, 0xF3, 0xFB, 0x08, 0xC6,
    0x91, 0xD1, 0xFB, 0x29, 0x95, 0xA3, 0x42, 0x30, 0x40, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04,
    0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02,
    0x01, 0x06, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x9A, 0xD8, 0x00, 0x30, 0x00, 0xE7, 0x6B,
    0x7F, 0x85, 0x18, 0xEE, 0x8B, 0xB6, 0xCE, 0x8A, 0x0C, 0xF8, 0x11, 0xE1, 0xBB, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48,
    0xCE, 0x3D, 0x04, 0x03, 0x03, 0x03, 0x69, 0x00, 0x30, 0x66, 0x02, 0x31, 0x00, 0xDD, 0xF8, 0xE0, 0x57, 0x47, 0x5B, 0xA7,
    0xE6, 0x0A, 0xC3, 0xBD, 0xF5, 0x80, 0x8A, 0x97, 0x35, 0x0D, 0x1B, 0x89, 0x3C, 0x54, 0x86, 0x77, 0x28, 0xCA, 0xA1, 0xF4,
    0x79, 0xDE, 0xB5, 0xE6, 0x38, 0xB0, 0xF0, 0x65, 0x70, 0x8C, 0x7F, 0x02, 0x54, 0xC2, 0xBF, 0xFF, 0xD8, 0xA1, 0x3E, 0xD9,
    0xCF, 0x02, 0x31, 0x00, 0xC4, 0x8D, 0x94, 0xFC, 0xDC, 0x53, 0xD2, 0xDC, 0x9D, 0x78, 0x16, 0x1F, 0x15, 0x33, 0x23, 0x53,
    0x52, 0xE3, 0x5A, 0x31, 0x5D, 0x9D, 0xCA, 0xAE, 0xBD, 0x13, 0x29, 0x44, 0x0D, 0x27, 0x5B, 0xA8, 0xE7, 0x68, 0x9C, 0x12,
    0xF7, 0x58, 0x3F, 0x2E, 0x72, 0x02, 0x57, 0xA3, 0x8F, 0xA1, 0x14, 0x2E
};

//thawte_Primary_Root_CA-G3_SHA256.der
const unsigned char gGlobalCIRootCa_G3[] = {
    0x30, 0x82, 0x04, 0x2A, 0x30, 0x82, 0x03, 0x12, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x60, 0x01, 0x97, 0xB7, 0x46,
    0xA7, 0xEA, 0xB4, 0xB4, 0x9A, 0xD6, 0x4B, 0x2F, 0xF7, 0x90, 0xFB, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30, 0x81, 0xAE, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
    0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C,
    0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1F, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x44,
    0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x2F, 0x28, 0x63,
    0x29, 0x20, 0x32, 0x30, 0x30, 0x38, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20,
    0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65,
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x24, 0x30, 0x22, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1B, 0x74, 0x68, 0x61, 0x77,
    0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2D,
    0x20, 0x47, 0x33, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x38, 0x30, 0x34, 0x30, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A,
    0x17, 0x0D, 0x33, 0x37, 0x31, 0x32, 0x30, 0x31, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xAE, 0x31, 0x0B,
    0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x13, 0x0C, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x1F, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x53,
    0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x38, 0x30, 0x36,
    0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x2F, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x38, 0x20, 0x74, 0x68, 0x61, 0x77,
    0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F,
    0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x24, 0x30, 0x22, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x13, 0x1B, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20,
    0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x33, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A,
    0x02, 0x82, 0x01, 0x01, 0x00, 0xB2, 0xBF, 0x27, 0x2C, 0xFB, 0xDB, 0xD8, 0x5B, 0xDD, 0x78, 0x7B, 0x1B, 0x9E, 0x77, 0x66,
    0x81, 0xCB, 0x3E, 0xBC, 0x7C, 0xAE, 0xF3, 0xA6, 0x27, 0x9A, 0x34, 0xA3, 0x68, 0x31, 0x71, 0x38, 0x33, 0x62, 0xE4, 0xF3,
    0x71, 0x66, 0x79, 0xB1, 0xA9, 0x65, 0xA3, 0xA5, 0x8B, 0xD5, 0x8F, 0x60, 0x2D, 0x3F, 0x42, 0xCC, 0xAA, 0x6B, 0x32, 0xC0,
    0x23, 0xCB, 0x2C, 0x41, 0xDD, 0xE4, 0xDF, 0xFC, 0x61, 0x9C, 0xE2, 0x73, 0xB2, 0x22, 0x95, 0x11, 0x43, 0x18, 0x5F, 0xC4,
    0xB6, 0x1F, 0x57, 0x6C, 0x0A, 0x05, 0x58, 0x22, 0xC8, 0x36, 0x4C, 0x3A, 0x7C, 0xA5, 0xD1, 0xCF, 0x86, 0xAF, 0x88, 0xA7,
    0x44, 0x02, 0x13, 0x74, 0x71, 0x73, 0x0A, 0x42, 0x59, 0x02, 0xF8, 0x1B, 0x14, 0x6B, 0x42, 0xDF, 0x6F, 0x5F, 0xBA, 0x6B,
    0x82, 0xA2, 0x9D, 0x5B, 0xE7, 0x4A, 0xBD, 0x1E, 0x01, 0x72, 0xDB, 0x4B, 0x74, 0xE8, 0x3B, 0x7F, 0x7F, 0x7D, 0x1F, 0x04,
    0xB4, 0x26, 0x9B, 0xE0, 0xB4, 0x5A, 0xAC, 0x47, 0x3D, 0x55, 0xB8, 0xD7, 0xB0, 0x26, 0x52, 0x28, 0x01, 0x31, 0x40, 0x66,
    0xD8, 0xD9, 0x24, 0xBD, 0xF6, 0x2A, 0xD8, 0xEC, 0x21, 0x49, 0x5C, 0x9B, 0xF6, 0x7A, 0xE9, 0x7F, 0x55, 0x35, 0x7E, 0x96,
    0x6B, 0x8D, 0x93, 0x93, 0x27, 0xCB, 0x92, 0xBB, 0xEA, 0xAC, 0x40, 0xC0, 0x9F, 0xC2, 0xF8, 0x80, 0xCF, 0x5D, 0xF4, 0x5A,
    0xDC, 0xCE, 0x74, 0x86, 0xA6, 0x3E, 0x6C, 0x0B, 0x53, 0xCA, 0xBD, 0x92, 0xCE, 0x19, 0x06, 0x72, 0xE6, 0x0C, 0x5C, 0x38,
    0x69, 0xC7, 0x04, 0xD6, 0xBC, 0x6C, 0xCE, 0x5B, 0xF6, 0xF7, 0x68, 0x9C, 0xDC, 0x25, 0x15, 0x48, 0x88, 0xA1, 0xE9, 0xA9,
    0xF8, 0x98, 0x9C, 0xE0, 0xF3, 0xD5, 0x31, 0x28, 0x61, 0x11, 0x6C, 0x67, 0x96, 0x8D, 0x39, 0x99, 0xCB, 0xC2, 0x45, 0x24,
    0x39, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x42, 0x30, 0x40, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF,
    0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03,
    0x02, 0x01, 0x06, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xAD, 0x6C, 0xAA, 0x94, 0x60, 0x9C,
    0xED, 0xE4, 0xFF, 0xFA, 0x3E, 0x0A, 0x74, 0x2B, 0x63, 0x03, 0xF7, 0xB6, 0x59, 0xBF, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x1A, 0x40, 0xD8, 0x95, 0x65, 0xAC,
    0x09, 0x92, 0x89, 0xC6, 0x39, 0xF4, 0x10, 0xE5, 0xA9, 0x0E, 0x66, 0x53, 0x5D, 0x78, 0xDE, 0xFA, 0x24, 0x91, 0xBB, 0xE7,
    0x44, 0x51, 0xDF, 0xC6, 0x16, 0x34, 0x0A, 0xEF, 0x6A, 0x44, 0x51, 0xEA, 0x2B, 0x07, 0x8A, 0x03, 0x7A, 0xC3, 0xEB, 0x3F,
    0x0A, 0x2C, 0x52, 0x16, 0xA0, 0x2B, 0x43, 0xB9, 0x25, 0x90, 0x3F, 0x70, 0xA9, 0x33, 0x25, 0x6D, 0x45, 0x1A, 0x28, 0x3B,
    0x27, 0xCF, 0xAA, 0xC3, 0x29, 0x42, 0x1B, 0xDF, 0x3B, 0x4C, 0xC0, 0x33, 0x34, 0x5B, 0x41, 0x88, 0xBF, 0x6B, 0x2B, 0x65,
    0xAF, 0x28, 0xEF, 0xB2, 0xF5, 0xC3, 0xAA, 0x66, 0xCE, 0x7B, 0x56, 0xEE, 0xB7, 0xC8, 0xCB, 0x67, 0xC1, 0xC9, 0x9C, 0x1A,
    0x18, 0xB8, 0xC4, 0xC3, 0x49, 0x03, 0xF1, 0x60, 0x0E, 0x50, 0xCD, 0x46, 0xC5, 0xF3, 0x77, 0x79, 0xF7, 0xB6, 0x15, 0xE0,
    0x38, 0xDB, 0xC7, 0x2F, 0x28, 0xA0, 0x0C, 0x3F, 0x77, 0x26, 0x74, 0xD9, 0x25, 0x12, 0xDA, 0x31, 0xDA, 0x1A, 0x1E, 0xDC,
    0x29, 0x41, 0x91, 0x22, 0x3C, 0x69, 0xA7, 0xBB, 0x02, 0xF2, 0xB6, 0x5C, 0x27, 0x03, 0x89, 0xF4, 0x06, 0xEA, 0x9B, 0xE4,
    0x72, 0x82, 0xE3, 0xA1, 0x09, 0xC1, 0xE9, 0x00, 0x19, 0xD3, 0x3E, 0xD4, 0x70, 0x6B, 0xBA, 0x71, 0xA6, 0xAA, 0x58, 0xAE,
    0xF4, 0xBB, 0xE9, 0x6C, 0xB6, 0xEF, 0x87, 0xCC, 0x9B, 0xBB, 0xFF, 0x39, 0xE6, 0x56, 0x61, 0xD3, 0x0A, 0xA7, 0xC4, 0x5C,
    0x4C, 0x60, 0x7B, 0x05, 0x77, 0x26, 0x7A, 0xBF, 0xD8, 0x07, 0x52, 0x2C, 0x62, 0xF7, 0x70, 0x63, 0xD9, 0x39, 0xBC, 0x6F,
    0x1C, 0xC2, 0x79, 0xDC, 0x76, 0x29, 0xAF, 0xCE, 0xC5, 0x2C, 0x64, 0x04, 0x5E, 0x88, 0x36, 0x6E, 0x31, 0xD4, 0x40, 0x1A,
    0x62, 0x34, 0x36, 0x3F, 0x35, 0x01, 0xAE, 0xAC, 0x63, 0xA0
};

//Samsung_OCF_RootCA.der
const unsigned char gRegionalRootCa[] = {
    0x30, 0x82, 0x02, 0x5D, 0x30, 0x82, 0x02, 0x01, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x30, 0x0C, 0x06, 0x08,
    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x30, 0x6B, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04,
    0x03, 0x13, 0x1F, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69,
    0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1C, 0x30, 0x1A,
    0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74,
    0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4B, 0x52, 0x30,
    0x20, 0x17, 0x0D, 0x31, 0x36, 0x31, 0x31, 0x32, 0x34, 0x30, 0x32, 0x35, 0x35, 0x31, 0x31, 0x5A, 0x18, 0x0F, 0x32, 0x30,
    0x36, 0x39, 0x31, 0x32, 0x33, 0x31, 0x31, 0x34, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x6B, 0x31, 0x28, 0x30, 0x26, 0x06,
    0x03, 0x55, 0x04, 0x03, 0x13, 0x1F, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72,
    0x6F, 0x6E, 0x69, 0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x14, 0x30,
    0x12, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31,
    0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C,
    0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
    0x4B, 0x52, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48,
    0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x62, 0xC7, 0xFF, 0x2B, 0x1F, 0xAC, 0x50, 0x50, 0x50, 0x11, 0x26,
    0xEE, 0xCA, 0xD4, 0xC3, 0x3F, 0x02, 0xCF, 0x21, 0xED, 0x17, 0xFF, 0xCF, 0xC1, 0xD4, 0xBE, 0xDB, 0xDD, 0xA6, 0xF1, 0x13,
    0xDC, 0x34, 0x81, 0x06, 0x40, 0x7C, 0x8F, 0x16, 0x61, 0x49, 0x0A, 0x7C, 0xD7, 0xCF, 0xEC, 0x75, 0xE1, 0xD4, 0xCE, 0x52,
    0x0A, 0x73, 0xA4, 0x7F, 0x05, 0xAB, 0x6A, 0x5B, 0x46, 0x38, 0xA4, 0xDE, 0x5F, 0xA3, 0x81, 0x91, 0x30, 0x81, 0x8E, 0x30,
    0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0xC6, 0x30, 0x32, 0x06, 0x03, 0x55,
    0x1D, 0x1F, 0x04, 0x2B, 0x30, 0x29, 0x30, 0x27, 0xA0, 0x25, 0xA0, 0x23, 0x86, 0x21, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
    0x2F, 0x70, 0x72, 0x6F, 0x64, 0x63, 0x61, 0x2E, 0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E,
    0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x72, 0x6C, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30,
    0x03, 0x01, 0x01, 0xFF, 0x30, 0x37, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x2B, 0x30, 0x29,
    0x30, 0x27, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x1B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
    0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E, 0x63, 0x6F,
    0x6D, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x03, 0x48, 0x00, 0x30, 0x45,
    0x02, 0x20, 0x11, 0x63, 0xD6, 0x92, 0x13, 0x7D, 0x2A, 0xDF, 0x5A, 0xB9, 0xBF, 0xC0, 0x78, 0xB0, 0x97, 0x33, 0x06, 0xA3,
    0xA9, 0xEC, 0x0B, 0x03, 0xF6, 0x8F, 0x19, 0x22, 0xE3, 0x66, 0x1F, 0xB2, 0x30, 0x4B, 0x02, 0x21, 0x00, 0xB7, 0xD1, 0xE7,
    0xA8, 0xDC, 0x5E, 0x81, 0x62, 0xB3, 0xF9, 0xC3, 0xC7, 0x4B, 0x50, 0xDB, 0x14, 0xC8, 0xFD, 0xFD, 0x1B, 0xEC, 0x5E, 0xAD,
    0x58, 0xFA, 0xA3, 0xDA, 0xFC, 0x8A, 0x41, 0xE3, 0x51
};

#ifndef _EXCLUDE_TEST_KEY_
//Samsung_OCF_TestRootCA.der
const unsigned char gRegionalTestRootCa[] = {
    0x30, 0x82, 0x02, 0x68, 0x30, 0x82, 0x02, 0x0C, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x02, 0x30, 0x0C, 0x06, 0x08,
    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x30, 0x70, 0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03, 0x55, 0x04,
    0x03, 0x13, 0x24, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69,
    0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x54, 0x45, 0x53, 0x54, 0x31,
    0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43,
    0x41, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20,
    0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
    0x13, 0x02, 0x4B, 0x52, 0x30, 0x20, 0x17, 0x0D, 0x31, 0x36, 0x31, 0x31, 0x32, 0x34, 0x30, 0x32, 0x34, 0x37, 0x32, 0x37,
    0x5A, 0x18, 0x0F, 0x32, 0x30, 0x36, 0x39, 0x31, 0x32, 0x33, 0x31, 0x31, 0x34, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x70,
    0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x24, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45,
    0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20,
    0x43, 0x41, 0x20, 0x54, 0x45, 0x53, 0x54, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43,
    0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13,
    0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31,
    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4B, 0x52, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86,
    0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x1C,
    0xF3, 0xBA, 0xBC, 0xBB, 0xA7, 0xC1, 0xC0, 0x35, 0x59, 0xFE, 0xBF, 0x80, 0x88, 0x6B, 0x68, 0x7F, 0x47, 0xF4, 0x80, 0xB7,
    0x75, 0x55, 0xB2, 0xDF, 0xAF, 0x4E, 0xFE, 0x3F, 0x91, 0x1F, 0xA5, 0x81, 0x4D, 0x4E, 0x12, 0x24, 0xF7, 0xB7, 0xDF, 0xA6,
    0x39, 0x61, 0x3B, 0x27, 0xEA, 0x1D, 0x76, 0x94, 0x68, 0x7C, 0x55, 0xB6, 0x0D, 0xD7, 0x89, 0x92, 0x97, 0xD0, 0x51, 0x53,
    0xA7, 0xE0, 0xD3, 0xA3, 0x81, 0x92, 0x30, 0x81, 0x8F, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04,
    0x04, 0x03, 0x02, 0x01, 0xC6, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x27, 0x30, 0x25, 0x30, 0x23, 0xA0, 0x21,
    0xA0, 0x1F, 0x86, 0x1D, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x2E, 0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E,
    0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x72, 0x6C, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13,
    0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x3C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07,
    0x01, 0x01, 0x04, 0x30, 0x30, 0x2E, 0x30, 0x2C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x20,
    0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2D, 0x74, 0x65, 0x73, 0x74, 0x2E, 0x73, 0x61, 0x6D,
    0x73, 0x75, 0x6E, 0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE,
    0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x21, 0x00, 0x88, 0xB2, 0x2D, 0xC1, 0x70, 0xE4,
    0x0C, 0x5C, 0xEF, 0xE9, 0x0A, 0x25, 0x00, 0xF9, 0x2E, 0xF9, 0x6D, 0x81, 0x56, 0x4B, 0x6E, 0xC4, 0x18, 0x0A, 0xBD, 0x7B,
    0x61, 0x37, 0xFA, 0x14, 0x36, 0x4C, 0x02, 0x20, 0x5A, 0xB4, 0xE2, 0x78, 0x50, 0x19, 0xE7, 0x14, 0x47, 0xDC, 0x19, 0xD2,
    0x1C, 0x6F, 0x97, 0x10, 0x5D, 0x87, 0x3C, 0x3F, 0x7D, 0xCB, 0xF4, 0x98, 0x49, 0xAE, 0x93, 0xE7, 0xD6, 0x16, 0xFA, 0x31
};

//jun
//global_ocf_connect_cert_root.der
const unsigned char gTrustCaChain1[] = {
    0x30, 0x82, 0x04, 0x20, 0x30, 0x82, 0x03, 0x08, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x34, 0x4E, 0xD5, 0x57, 0x20,
    0xD5, 0xED, 0xEC, 0x49, 0xF4, 0x2F, 0xCE, 0x37, 0xDB, 0x2B, 0x6D, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0xA9, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
    0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C,
    0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1F, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x44,
    0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x2F, 0x28, 0x63,
    0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x20,
    0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65,
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x74, 0x68, 0x61, 0x77,
    0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1E,
    0x17, 0x0D, 0x30, 0x36, 0x31, 0x31, 0x31, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x33, 0x36, 0x30,
    0x37, 0x31, 0x36, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xA9, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55,
    0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0C, 0x74, 0x68, 0x61,
    0x77, 0x74, 0x65, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1F,
    0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
    0x65, 0x73, 0x20, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x38, 0x30, 0x36, 0x06, 0x03, 0x55, 0x04, 0x0B,
    0x13, 0x2F, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2C, 0x20, 0x49,
    0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64,
    0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16,
    0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20,
    0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05,
    0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xAC, 0xA0, 0xF0, 0xFB, 0x80,
    0x59, 0xD4, 0x9C, 0xC7, 0xA4, 0xCF, 0x9D, 0xA1, 0x59, 0x73, 0x09, 0x10, 0x45, 0x0C, 0x0D, 0x2C, 0x6E, 0x68, 0xF1, 0x6C,
    0x5B, 0x48, 0x68, 0x49, 0x59, 0x37, 0xFC, 0x0B, 0x33, 0x19, 0xC2, 0x77, 0x7F, 0xCC, 0x10, 0x2D, 0x95, 0x34, 0x1C, 0xE6,
    0xEB, 0x4D, 0x09, 0xA7, 0x1C, 0xD2, 0xB8, 0xC9, 0x97, 0x36, 0x02, 0xB7, 0x89, 0xD4, 0x24, 0x5F, 0x06, 0xC0, 0xCC, 0x44,
    0x94, 0x94, 0x8D, 0x02, 0x62, 0x6F, 0xEB, 0x5A, 0xDD, 0x11, 0x8D, 0x28, 0x9A, 0x5C, 0x84, 0x90, 0x10, 0x7A, 0x0D, 0xBD,
    0x74, 0x66, 0x2F, 0x6A, 0x38, 0xA0, 0xE2, 0xD5, 0x54, 0x44, 0xEB, 0x1D, 0x07, 0x9F, 0x07, 0xBA, 0x6F, 0xEE, 0xE9, 0xFD,
    0x4E, 0x0B, 0x29, 0xF5, 0x3E, 0x84, 0xA0, 0x01, 0xF1, 0x9C, 0xAB, 0xF8, 0x1C, 0x7E, 0x89, 0xA4, 0xE8, 0xA1, 0xD8, 0x71,
    0x65, 0x0D, 0xA3, 0x51, 0x7B, 0xEE, 0xBC, 0xD2, 0x22, 0x60, 0x0D, 0xB9, 0x5B, 0x9D, 0xDF, 0xBA, 0xFC, 0x51, 0x5B, 0x0B,
    0xAF, 0x98, 0xB2, 0xE9, 0x2E, 0xE9, 0x04, 0xE8, 0x62, 0x87, 0xDE, 0x2B, 0xC8, 0xD7, 0x4E, 0xC1, 0x4C, 0x64, 0x1E, 0xDD,
    0xCF, 0x87, 0x58, 0xBA, 0x4A, 0x4F, 0xCA, 0x68, 0x07, 0x1D, 0x1C, 0x9D, 0x4A, 0xC6, 0xD5, 0x2F, 0x91, 0xCC, 0x7C, 0x71,
    0x72, 0x1C, 0xC5, 0xC0, 0x67, 0xEB, 0x32, 0xFD, 0xC9, 0x92, 0x5C, 0x94, 0xDA, 0x85, 0xC0, 0x9B, 0xBF, 0x53, 0x7D, 0x2B,
    0x09, 0xF4, 0x8C, 0x9D, 0x91, 0x1F, 0x97, 0x6A, 0x52, 0xCB, 0xDE, 0x09, 0x36, 0xA4, 0x77, 0xD8, 0x7B, 0x87, 0x50, 0x44,
    0xD5, 0x3E, 0x6E, 0x29, 0x69, 0xFB, 0x39, 0x49, 0x26, 0x1E, 0x09, 0xA5, 0x80, 0x7B, 0x40, 0x2D, 0xEB, 0xE8, 0x27, 0x85,
    0xC9, 0xFE, 0x61, 0xFD, 0x7E, 0xE6, 0x7C, 0x97, 0x1D, 0xD5, 0x9D, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x42, 0x30, 0x40,
    0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0E, 0x06,
    0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E,
    0x04, 0x16, 0x04, 0x14, 0x7B, 0x5B, 0x45, 0xCF, 0xAF, 0xCE, 0xCB, 0x7A, 0xFD, 0x31, 0x92, 0x1A, 0x6A, 0xB6, 0xF3, 0x46,
    0xEB, 0x57, 0x48, 0x50, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
    0x82, 0x01, 0x01, 0x00, 0x79, 0x11, 0xC0, 0x4B, 0xB3, 0x91, 0xB6, 0xFC, 0xF0, 0xE9, 0x67, 0xD4, 0x0D, 0x6E, 0x45, 0xBE,
    0x55, 0xE8, 0x93, 0xD2, 0xCE, 0x03, 0x3F, 0xED, 0xDA, 0x25, 0xB0, 0x1D, 0x57, 0xCB, 0x1E, 0x3A, 0x76, 0xA0, 0x4C, 0xEC,
    0x50, 0x76, 0xE8, 0x64, 0x72, 0x0C, 0xA4, 0xA9, 0xF1, 0xB8, 0x8B, 0xD6, 0xD6, 0x87, 0x84, 0xBB, 0x32, 0xE5, 0x41, 0x11,
    0xC0, 0x77, 0xD9, 0xB3, 0x60, 0x9D, 0xEB, 0x1B, 0xD5, 0xD1, 0x6E, 0x44, 0x44, 0xA9, 0xA6, 0x01, 0xEC, 0x55, 0x62, 0x1D,
    0x77, 0xB8, 0x5C, 0x8E, 0x48, 0x49, 0x7C, 0x9C, 0x3B, 0x57, 0x11, 0xAC, 0xAD, 0x73, 0x37, 0x8E, 0x2F, 0x78, 0x5C, 0x90,
    0x68, 0x47, 0xD9, 0x60, 0x60, 0xE6, 0xFC, 0x07, 0x3D, 0x22, 0x20, 0x17, 0xC4, 0xF7, 0x16, 0xE9, 0xC4, 0xD8, 0x72, 0xF9,
    0xC8, 0x73, 0x7C, 0xDF, 0x16, 0x2F, 0x15, 0xA9, 0x3E, 0xFD, 0x6A, 0x27, 0xB6, 0xA1, 0xEB, 0x5A, 0xBA, 0x98, 0x1F, 0xD5,
    0xE3, 0x4D, 0x64, 0x0A, 0x9D, 0x13, 0xC8, 0x61, 0xBA, 0xF5, 0x39, 0x1C, 0x87, 0xBA, 0xB8, 0xBD, 0x7B, 0x22, 0x7F, 0xF6,
    0xFE, 0xAC, 0x40, 0x79, 0xE5, 0xAC, 0x10, 0x6F, 0x3D, 0x8F, 0x1B, 0x79, 0x76, 0x8B, 0xC4, 0x37, 0xB3, 0x21, 0x18, 0x84,
    0xE5, 0x36, 0x00, 0xEB, 0x63, 0x20, 0x99, 0xB9, 0xE9, 0xFE, 0x33, 0x04, 0xBB, 0x41, 0xC8, 0xC1, 0x02, 0xF9, 0x44, 0x63,
    0x20, 0x9E, 0x81, 0xCE, 0x42, 0xD3, 0xD6, 0x3F, 0x2C, 0x76, 0xD3, 0x63, 0x9C, 0x59, 0xDD, 0x8F, 0xA6, 0xE1, 0x0E, 0xA0,
    0x2E, 0x41, 0xF7, 0x2E, 0x95, 0x47, 0xCF, 0xBC, 0xFD, 0x33, 0xF3, 0xF6, 0x0B, 0x61, 0x7E, 0x7E, 0x91, 0x2B, 0x81, 0x47,
    0xC2, 0x27, 0x30, 0xEE, 0xA7, 0x10, 0x5D, 0x37, 0x8F, 0x5C, 0x39, 0x2B, 0xE4, 0x04, 0xF0, 0x7B, 0x8D, 0x56, 0x8C, 0x68
};

//Samsung_OCF_RootCA.der
const unsigned char gTrustCaChain2[] = {
    0x30, 0x82, 0x02, 0x5D, 0x30, 0x82, 0x02, 0x01, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x30, 0x0C, 0x06, 0x08,
    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x30, 0x6B, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04,
    0x03, 0x13, 0x1F, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69,
    0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03,
    0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1C, 0x30, 0x1A,
    0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74,
    0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4B, 0x52, 0x30,
    0x20, 0x17, 0x0D, 0x31, 0x36, 0x31, 0x31, 0x32, 0x34, 0x30, 0x32, 0x35, 0x35, 0x31, 0x31, 0x5A, 0x18, 0x0F, 0x32, 0x30,
    0x36, 0x39, 0x31, 0x32, 0x33, 0x31, 0x31, 0x34, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x6B, 0x31, 0x28, 0x30, 0x26, 0x06,
    0x03, 0x55, 0x04, 0x03, 0x13, 0x1F, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72,
    0x6F, 0x6E, 0x69, 0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x14, 0x30,
    0x12, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31,
    0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C,
    0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
    0x4B, 0x52, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48,
    0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x62, 0xC7, 0xFF, 0x2B, 0x1F, 0xAC, 0x50, 0x50, 0x50, 0x11, 0x26,
    0xEE, 0xCA, 0xD4, 0xC3, 0x3F, 0x02, 0xCF, 0x21, 0xED, 0x17, 0xFF, 0xCF, 0xC1, 0xD4, 0xBE, 0xDB, 0xDD, 0xA6, 0xF1, 0x13,
    0xDC, 0x34, 0x81, 0x06, 0x40, 0x7C, 0x8F, 0x16, 0x61, 0x49, 0x0A, 0x7C, 0xD7, 0xCF, 0xEC, 0x75, 0xE1, 0xD4, 0xCE, 0x52,
    0x0A, 0x73, 0xA4, 0x7F, 0x05, 0xAB, 0x6A, 0x5B, 0x46, 0x38, 0xA4, 0xDE, 0x5F, 0xA3, 0x81, 0x91, 0x30, 0x81, 0x8E, 0x30,
    0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0xC6, 0x30, 0x32, 0x06, 0x03, 0x55,
    0x1D, 0x1F, 0x04, 0x2B, 0x30, 0x29, 0x30, 0x27, 0xA0, 0x25, 0xA0, 0x23, 0x86, 0x21, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
    0x2F, 0x70, 0x72, 0x6F, 0x64, 0x63, 0x61, 0x2E, 0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E,
    0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x72, 0x6C, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30,
    0x03, 0x01, 0x01, 0xFF, 0x30, 0x37, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x2B, 0x30, 0x29,
    0x30, 0x27, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x1B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
    0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E, 0x63, 0x6F,
    0x6D, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x03, 0x48, 0x00, 0x30, 0x45,
    0x02, 0x20, 0x11, 0x63, 0xD6, 0x92, 0x13, 0x7D, 0x2A, 0xDF, 0x5A, 0xB9, 0xBF, 0xC0, 0x78, 0xB0, 0x97, 0x33, 0x06, 0xA3,
    0xA9, 0xEC, 0x0B, 0x03, 0xF6, 0x8F, 0x19, 0x22, 0xE3, 0x66, 0x1F, 0xB2, 0x30, 0x4B, 0x02, 0x21, 0x00, 0xB7, 0xD1, 0xE7,
    0xA8, 0xDC, 0x5E, 0x81, 0x62, 0xB3, 0xF9, 0xC3, 0xC7, 0x4B, 0x50, 0xDB, 0x14, 0xC8, 0xFD, 0xFD, 0x1B, 0xEC, 0x5E, 0xAD,
    0x58, 0xFA, 0xA3, 0xDA, 0xFC, 0x8A, 0x41, 0xE3, 0x51
};

//Samsung_OCF_TestRootCA.der
const unsigned char gTrustCaChain3[] = {
    0x30, 0x82, 0x02, 0x68, 0x30, 0x82, 0x02, 0x0C, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x02, 0x30, 0x0C, 0x06, 0x08,
    0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x30, 0x70, 0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03, 0x55, 0x04,
    0x03, 0x13, 0x24, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69,
    0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x54, 0x45, 0x53, 0x54, 0x31,
    0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43,
    0x41, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20,
    0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
    0x13, 0x02, 0x4B, 0x52, 0x30, 0x20, 0x17, 0x0D, 0x31, 0x36, 0x31, 0x31, 0x32, 0x34, 0x30, 0x32, 0x34, 0x37, 0x32, 0x37,
    0x5A, 0x18, 0x0F, 0x32, 0x30, 0x36, 0x39, 0x31, 0x32, 0x33, 0x31, 0x31, 0x34, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x70,
    0x31, 0x2D, 0x30, 0x2B, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x24, 0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45,
    0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x20, 0x4F, 0x43, 0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20,
    0x43, 0x41, 0x20, 0x54, 0x45, 0x53, 0x54, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0B, 0x4F, 0x43,
    0x46, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13,
    0x53, 0x61, 0x6D, 0x73, 0x75, 0x6E, 0x67, 0x20, 0x45, 0x6C, 0x65, 0x63, 0x74, 0x72, 0x6F, 0x6E, 0x69, 0x63, 0x73, 0x31,
    0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4B, 0x52, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86,
    0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x1C,
    0xF3, 0xBA, 0xBC, 0xBB, 0xA7, 0xC1, 0xC0, 0x35, 0x59, 0xFE, 0xBF, 0x80, 0x88, 0x6B, 0x68, 0x7F, 0x47, 0xF4, 0x80, 0xB7,
    0x75, 0x55, 0xB2, 0xDF, 0xAF, 0x4E, 0xFE, 0x3F, 0x91, 0x1F, 0xA5, 0x81, 0x4D, 0x4E, 0x12, 0x24, 0xF7, 0xB7, 0xDF, 0xA6,
    0x39, 0x61, 0x3B, 0x27, 0xEA, 0x1D, 0x76, 0x94, 0x68, 0x7C, 0x55, 0xB6, 0x0D, 0xD7, 0x89, 0x92, 0x97, 0xD0, 0x51, 0x53,
    0xA7, 0xE0, 0xD3, 0xA3, 0x81, 0x92, 0x30, 0x81, 0x8F, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04,
    0x04, 0x03, 0x02, 0x01, 0xC6, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x27, 0x30, 0x25, 0x30, 0x23, 0xA0, 0x21,
    0xA0, 0x1F, 0x86, 0x1D, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x61, 0x2E, 0x73, 0x61, 0x6D, 0x73, 0x75, 0x6E,
    0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x72, 0x6C, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13,
    0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x3C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07,
    0x01, 0x01, 0x04, 0x30, 0x30, 0x2E, 0x30, 0x2C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x20,
    0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2D, 0x74, 0x65, 0x73, 0x74, 0x2E, 0x73, 0x61, 0x6D,
    0x73, 0x75, 0x6E, 0x67, 0x69, 0x6F, 0x74, 0x73, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE,
    0x3D, 0x04, 0x03, 0x02, 0x05, 0x00, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x21, 0x00, 0x88, 0xB2, 0x2D, 0xC1, 0x70, 0xE4,
    0x0C, 0x5C, 0xEF, 0xE9, 0x0A, 0x25, 0x00, 0xF9, 0x2E, 0xF9, 0x6D, 0x81, 0x56, 0x4B, 0x6E, 0xC4, 0x18, 0x0A, 0xBD, 0x7B,
    0x61, 0x37, 0xFA, 0x14, 0x36, 0x4C, 0x02, 0x20, 0x5A, 0xB4, 0xE2, 0x78, 0x50, 0x19, 0xE7, 0x14, 0x47, 0xDC, 0x19, 0xD2,
    0x1C, 0x6F, 0x97, 0x10, 0x5D, 0x87, 0x3C, 0x3F, 0x7D, 0xCB, 0xF4, 0x98, 0x49, 0xAE, 0x93, 0xE7, 0xD6, 0x16, 0xFA, 0x31
};


#endif //_EXCLUDE_TEST_KEY_

/*
 * This API added as workaround to test certificate based TLS connection.
 * It will be replaced to use TZ or eSE based key protection.
 *
 * NOTE : This API should be invoked after SM_GenerateMacBasedDeviceId invoked.
 */
static OCStackResult SaveSignedAsymmetricKey(OicUuid_t* subjectUuid)
{
    OCStackResult res = OC_STACK_ERROR;
    uint16_t credId = 0;

    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN: %s", __func__);

    // For D2S

    /*
     * 1. Save the Trust CA cert chain.
     */

//jun
    res = CredSaveTrustCertChain(subjectUuid, gTrustCaChain1, sizeof(gTrustCaChain1), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #1 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "global_ocf_connect_cert_root.der saved w/ cred ID=%d", credId);

    res = CredSaveTrustCertChain(subjectUuid, gTrustCaChain2, sizeof(gTrustCaChain2), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #2 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Samsung_OCF_RootCA.der saved w/ cred ID=%d", credId);

    res = CredSaveTrustCertChain(subjectUuid, gTrustCaChain3, sizeof(gTrustCaChain3), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #3 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Samsung_OCF_TestRootCA.der saved w/ cred ID=%d", credId);


     //jun
#if 0
//#ifdef USE_SSS
#if 1
    res = SSSRootCAHandler(subjectUuid, credId);
    if(OC_STACK_OK != res)
    {
    	return res;
    }
#else
     //For global CI : thawte_Primary_Root_CA.der
    res = CredSaveTrustCertChain(subjectUuid, gGlobalCIRootCa, sizeof(gGlobalCIRootCa), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #1 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "thawte_Primary_Root_CA.der saved w/ cred ID=%d", credId);

    //For global CI : thawte_Primary_Root_CA-G2_ECC.der
    res = CredSaveTrustCertChain(subjectUuid, gGlobalCIRootCa_G2, sizeof(gGlobalCIRootCa_G2), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #2 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "thawte_Primary_Root_CA-G2_ECC.der saved w/ cred ID=%d", credId);

    //For global CI : thawte_Primary_Root_CA-G3_SHA256.der
    res = CredSaveTrustCertChain(subjectUuid, gGlobalCIRootCa_G3, sizeof(gGlobalCIRootCa_G3), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #3 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "thawte_Primary_Root_CA-G3_SHA256.der saved w/ cred ID=%d", credId);

    //For regional CI w/ product : Samsung_OCF_RootCA.der
    res = CredSaveTrustCertChain(subjectUuid, gRegionalRootCa, sizeof(gRegionalRootCa), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #4 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Samsung_OCF_RootCA.der saved w/ cred ID=%d", credId);

#ifndef _EXCLUDE_TEST_KEY_
    //For regional CI w/ test : Samsung_OCF_RootCA.der
    res = CredSaveTrustCertChain(subjectUuid, gRegionalTestRootCa, sizeof(gRegionalTestRootCa), OIC_ENCODING_DER, TRUST_CA, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveTrustCertChain #5 error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Samsung_OCF_TestRootCA.der saved w/ cred ID=%d", credId);
#endif //_EXCLUDE_TEST_KEY_
#endif
#endif

#ifndef _EXCLUDE_TEST_KEY_
    /*
     * 2. Save the key for D2S (primary cert & key)
     */
    res = SeckeySetup(DM_GetCertificateFilePath(), &primaryCert, OIC_ENCODING_DER);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SeckeySetup error");
        return res;
    }
    res = SeckeySetup(DM_GetPrivateKeyFilePath(), &primaryKey, OIC_ENCODING_RAW);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SeckeySetup error");
        return res;
    }
    res = CredSaveOwnCert(subjectUuid, &primaryCert, &primaryKey, PRIMARY_CERT, &credId);
    if(OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveOwnCertChain error");
        return res;
    }
    THINGS_LOG_D(THINGS_DEBUG, TAG, "Primary cert & key saved w/ cred ID=%d", credId);
#endif //_EXCLUDE_TEST_KEY_


    // For D2D
    if(gIsMfgCertRequired)
    {
        /*
         * 3. Save the MFG trust CA cert chain.
         */
#ifndef _EXCLUDE_TEST_KEY_
        res = CredSaveTrustCertChain(subjectUuid, gRegionalTestRootCa, sizeof(gRegionalTestRootCa), OIC_ENCODING_DER, MF_TRUST_CA, &credId);
#else
        res = CredSaveTrustCertChain(subjectUuid, gRegionalRootCa, sizeof(gRegionalRootCa), OIC_ENCODING_DER, MF_TRUST_CA, &credId);
#endif //_EXCLUDE_TEST_KEY_
        if(OC_STACK_OK != res)
        {
            THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveOwnCertChain error");
            return res;
        }
        THINGS_LOG_D(THINGS_DEBUG, TAG, "MFG trust CA chain saved w/ cred ID=%d", credId);
#ifndef _EXCLUDE_TEST_KEY_
        /*
         * 4. Save the key for D2D (manufacturer cert & key)
         */
        res = CredSaveOwnCert(subjectUuid, &primaryCert, &primaryKey, MF_PRIMARY_CERT, &credId);
        if(OC_STACK_OK != res)
        {
            THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SRPCredSaveOwnCertChain error");
            return res;
        }
        THINGS_LOG_D(THINGS_DEBUG, TAG, "MFG primary cert & key saved w/ cred ID=%d", credId);
#endif //_EXCLUDE_TEST_KEY_
    }

#ifndef _EXCLUDE_TEST_KEY_
    if (primaryCert.data != NULL) {
        DAFree(primaryCert.data);
    }

    if (primaryKey.data != NULL) {
        DAFree(primaryKey.data);
    }
#endif //_EXCLUDE_TEST_KEY_

    THINGS_LOG_D(THINGS_DEBUG, TAG, "Out: %s", __func__);

    return res;
}

int SM_SaveAcl(const char* uuid, const char* resourceUri, const char* resourceType, const char* interfaceName, uint16_t permission)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN : %s", __func__);

    if(!uuid)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "UUID is NULL");
        return OIC_SEC_ERROR;
    }
    if(!resourceUri)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Resource URI is NULL");
        return OIC_SEC_ERROR;
    }
    if(!resourceType)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Resource Type is NULL");
        return OIC_SEC_ERROR;
    }
    if(!interfaceName)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Interface Name is NULL");
        return OIC_SEC_ERROR;
    }
    if(0 == permission || ACL_PERMISSION_FULL < permission)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "Invalid Access Permission value : %d", permission);
        return OIC_SEC_ERROR;
    }

    OicUuid_t oicUuid;
    memset(&oicUuid, 0x00, sizeof(OicUuid_t));
    if (strncmp(uuid, "*", strlen("*")) == 0)
    {
        oicUuid.id[0] = 0x2A; // '*'
    }
    else
    {
        if(OC_STACK_OK != ConvertStrToUuid(uuid, &oicUuid))
        {
            THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "cloudUuid is NULL");
            return OIC_SEC_ERROR;
        }
    }

    // allocate memory for |acl| struct
    OicSecAcl_t* acl = (OicSecAcl_t*) DACalloc(1, sizeof(OicSecAcl_t));
    if(!acl)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, " %s : DACalloc error return", __func__);
        return OIC_SEC_ERROR;
    }
    OicSecAce_t* ace = (OicSecAce_t*) DACalloc(1, sizeof(OicSecAce_t));
    if(!ace)
    {
        DAFree(acl);
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        return OIC_SEC_ERROR;
    }
    LL_APPEND(acl->aces, ace);

    memcpy(ace->subjectuuid.id, oicUuid.id, sizeof(oicUuid.id));

    OicSecRsrc_t* rsrc = (OicSecRsrc_t*)DACalloc(1, sizeof(OicSecRsrc_t));
    if(!rsrc)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "%s : DACalloc error return", __func__);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }

    size_t len = strlen(resourceUri)+1;  // '1' for null termination
    rsrc->href = (char*) DACalloc(len, sizeof(char));
    if(!rsrc->href)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    DAStrncpy(rsrc->href, resourceUri, len);

    size_t arrLen = 1;
    rsrc->typeLen = arrLen;
    rsrc->types = (char**)DACalloc(arrLen, sizeof(char*));
    if(!rsrc->types)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    rsrc->types[0] = OICStrdup(resourceType);
    if(!rsrc->types[0])
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }

    rsrc->interfaceLen = 2;
    rsrc->interfaces = (char**)DACalloc(arrLen, sizeof(char*));
    if(!rsrc->interfaces)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }

    //baseline should be added as defualt interface
    rsrc->interfaces[0] = OICStrdup("oic.if.baseline");
    if(!rsrc->interfaces[0])
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    rsrc->interfaces[1] = OICStrdup(interfaceName);  // ignore
    if(!rsrc->interfaces[1])
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    LL_APPEND(ace->resources, rsrc);

    ace->permission = permission;   // CRUDN

    OCStackResult installRes = InstallACL(acl);
    if(OC_STACK_DUPLICATE_REQUEST == installRes)
    {
        THINGS_LOG_D(THINGS_WARNING, TAG,  "%s : [%s]'s ACL already installed.", __func__, uuid);
    }
    else if(OC_STACK_OK != installRes)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
        return OIC_SEC_ERROR;
    }
    DeleteACLList(acl);

    THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT : %s", __func__);

    return OIC_SEC_OK;
}


int SM_SaveCloudAcl(const char* cloudUuid)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN : %s", __func__);

    if(!cloudUuid)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "cloudUuid is NULL");
        return OIC_SEC_ERROR;
    }

    OicUuid_t oicUuid;
    if(OC_STACK_OK != ConvertStrToUuid(cloudUuid, &oicUuid))
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "cloudUuid is NULL");
        return OIC_SEC_ERROR;
    }

    // allocate memory for |acl| struct
    OicSecAcl_t* acl = (OicSecAcl_t*) DACalloc(1, sizeof(OicSecAcl_t));
    if(!acl)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, " %s : DACalloc error return", __func__);
        return OIC_SEC_ERROR;
    }
    OicSecAce_t* ace = (OicSecAce_t*) DACalloc(1, sizeof(OicSecAce_t));
    if(!ace)
    {
        DAFree(acl);
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        return OIC_SEC_ERROR;
    }
    LL_APPEND(acl->aces, ace);

    memcpy(ace->subjectuuid.id, oicUuid.id, sizeof(oicUuid.id));

    OicSecRsrc_t* rsrc = (OicSecRsrc_t*)DACalloc(1, sizeof(OicSecRsrc_t));
    if(!rsrc)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "%s : DACalloc error return", __func__);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }

    char href[] = "*";
    size_t len = strlen(href)+1;  // '1' for null termination
    rsrc->href = (char*) DACalloc(len, sizeof(char));
    if(!rsrc->href)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    DAStrncpy(rsrc->href, href, len);

    size_t arrLen = 1;
    rsrc->typeLen = arrLen;
    rsrc->types = (char**)DACalloc(arrLen, sizeof(char*));
    if(!rsrc->types)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    rsrc->types[0] = OICStrdup("x.com.samsung.cloudconnection");   // ignore
    if(!rsrc->types[0])
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }

    rsrc->interfaceLen = 1;
    rsrc->interfaces = (char**)DACalloc(arrLen, sizeof(char*));
    if(!rsrc->interfaces)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : DACalloc error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    rsrc->interfaces[0] = OICStrdup("oic.if.baseline");  // ignore
    if(!rsrc->interfaces[0])
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
        FreeRsrc(rsrc);
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    LL_APPEND(ace->resources, rsrc);

    ace->permission = 31;   // CRUDN

    OCStackResult installRes = InstallACL(acl);
    if(OC_STACK_DUPLICATE_REQUEST == installRes)
    {
        THINGS_LOG_D(THINGS_WARNING, TAG,  "%s : [%s]'s ACL already installed.", __func__, cloudUuid);
    }
    else if(OC_STACK_OK != installRes)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG,  "%s : OICStrdup error return", __func__);
				/*SVACE warning fix*/
        DeleteACLList(acl);
        return OIC_SEC_ERROR;
    }
    DeleteACLList(acl);

    THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT : %s", __func__);

    return OIC_SEC_OK;
}

void SM_SetOTMEventHandler(OicSecOtmEventHandler_t otmEventHandler)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN : %s", __func__);

    SetOtmEventHandler(otmEventHandler);

    THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT : %s", __func__);
}

int SM_SetMOTStatus(bool enable)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN : %s", __func__);
#ifndef OCF_RTOS
    OCStackResult res = SetMOTStatus(enable);
    if (OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "SetMOTStatus error : %d", res);
        return OIC_SEC_ERROR;
    }
#endif
    THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT : %s", __func__);
    return OIC_SEC_OK;
}

int SM_SavePreconfiguredPin(const char* pin)
{
    THINGS_LOG_D(THINGS_DEBUG, TAG, "IN : %s", __func__);
#ifndef OCF_RTOS
    OCStackResult res = AddPreconfPinCredential(pin);
    if (OC_STACK_OK != res)
    {
        THINGS_LOG_D_ERROR(THINGS_ERROR, TAG, "AddPreconfPinCredential error : %d", res);
        return OIC_SEC_ERROR;
    }
#endif
    THINGS_LOG_D(THINGS_DEBUG, TAG, "OUT : %s", __func__);
    return OIC_SEC_OK;
}

// ++ Added by Chul Lee : to test certificate based (D)TLS connection for  D2D & D2S
//

// int SM_RegisterPINGeneratedCB(PINGeneratedFuncType func)
// {
//     if(func)
//     {
//         gPINGeneratedCB = func;

//         SetGeneratePinCB(gPINGeneratedCB);
//         return 1;
//     }
//     else
//     {
//         THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Invalid PINGeneratedCB function");
//         return 0;
//     }
// }

// int SM_RegisterUserConfirmCB(UserConfirmResultFuncType func)
// {
//     if(func)
//     {
//         gUserConfirmCB = func;

//         SetUserConfirmCB(NULL, GetUserConfirmation);
//         return 1;
//     }
//     else
//     {
//         THINGS_LOG_ERROR(THINGS_ERROR, TAG, "Invalid UserConformCB function");
//         return 0;
//     }
// }
