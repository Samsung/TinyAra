/**************************************************************************************************
*
* Copyright 2020 Samsung Electronics All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
* either express or implied. See the License for the specific
* language governing permissions and limitations under the License.
*
***************************************************************************************************
***************************************************************************************************
*
*   Copyright (C) 2020 Gregory Nutt. All rights reserved.
*   Author: Gregory Nutt <gnutt@nuttx.org>
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in
*    the documentation and/or other materials provided with the
*    distribution.
* 3. Neither the name NuttX nor the names of its contributors may be
*    used to endorse or promote products derived from this software
*    without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*
***************************************************************************************************/

#include <tinyara/config.h>
#include <tinyara/seclink_drv.h>
#include <tinyara/security_hal.h>

#include <mbedtls/rsa.h>
#include <mbedtls/ecdh.h>
#include <mbedtls/ecdsa.h>
#include <mbedtls/dhm.h>
#include <mbedtls/cipher.h>

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define AWRAP_TAG "[AMEBA_WRAPPER]"

#define AWRAP_ENTER                                                                 \
	do {                                                                             \
		sedbg(AWRAP_TAG"[INFO] %s %s:%d\n", __FUNCTION__, __FILE__, __LINE__);       \
	} while (0)

#define HAL_MAX_RANDOM_SIZE 256
#define HAL_MAX_BUF_SIZE 2048
#define HAL_MAX_SHARED_SECRET_LEN 256
#define KEY_STORAGE_INDEX_MAX 32

#define AES_128_KEY_SIZE 16
#define AES_192_KEY_SIZE 24
#define AES_256_KEY_SIZE 32
#define MBEDTLS_HASH_SHA224 1
#define MBEDTLS_HASH_SHA256 0
#define MBEDTLS_HASH_SHA384 1
#define MBEDTLS_HASH_SHA512 0

/* Factory Key and Cert define */
#define FACTORYKEY_RTL_DEVICE (0x00010120)
#define FACTORYKEY_RTL_CERT (0x00010122)

#define HAL_COPY_DATA(in, out, len)                     \
	do {                                                \
		if (in->data == NULL) {                         \
			return HAL_INVALID_ARGS;                    \
		}                                               \
		memcpy(in->data, out, len);                     \
		in->data_len = len;                             \
	} while (0)

#define HAL_COPY_PRIV_DATA(in, out, len)                \
	do {                                                \
		if (in->priv == NULL) {                         \
			return HAL_INVALID_ARGS;                    \
		}                                               \
		memcpy(in->priv, out, len);                     \
		in->priv_len = len;                             \
	} while (0)

static const unsigned char EC_Private_Key[128] = {
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
};

/* DER format Cert */
static const unsigned char HA_IOT_Device_Cert[681] = {
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x2e, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A
};

/* RSA 1024 => N, P, Q, D, E element */
static const unsigned char RSA_1024_N[128] = {
	0x80, 0x80, 0xa2, 0x34, 0x24, 0xe0, 0x64, 0xf8, 0x94, 0x47, 0xf9, 0x3f, 0xc7, 0x66, 0x5d, 0x71,
	0xd3, 0x20, 0x1a, 0xf1, 0xfb, 0xef, 0x2, 0x22, 0x7b, 0x78, 0xb7, 0xcc, 0x7a, 0x3a, 0x6a, 0x23,
	0xa7, 0xd9, 0x88, 0x87, 0xd7, 0x15, 0x4b, 0x38, 0xd3, 0xfd, 0xcf, 0x15, 0x92, 0xac, 0x3b, 0x38,
	0xf2, 0x24, 0x8a, 0xe2, 0xdf, 0x12, 0xca, 0x3e, 0xc8, 0xc0, 0x9d, 0x8a, 0x98, 0xa0, 0x26, 0xeb,
	0xdf, 0x2a, 0xe2, 0x8, 0xa4, 0x1f, 0x2f, 0x72, 0x72, 0x8b, 0xc5, 0xcb, 0x8b, 0xd8, 0x54, 0xf7,
	0xad, 0x61, 0x31, 0x7d, 0xc8, 0x76, 0x8a, 0xb7, 0x67, 0x64, 0xc9, 0x55, 0xcf, 0x5e, 0x48, 0xfa,
	0x11, 0x81, 0x21, 0x43, 0xca, 0x29, 0x46, 0x9b, 0x6a, 0x5f, 0xb3, 0xcf, 0x6c, 0x22, 0xb, 0xde,
	0x38, 0x33, 0xd3, 0xec, 0xc4, 0x64, 0x37, 0x6a, 0x61, 0x98, 0x4b, 0x80, 0xa9, 0x52, 0x1c, 0x8f
};

static const unsigned char RSA_1024_P[64] = {
	0xba, 0xac, 0x67, 0x76, 0x10, 0x41, 0xaa, 0xd4, 0x10, 0x6d, 0xe7, 0xc6, 0xfd, 0x30, 0x3a, 0xaf,
	0x43, 0xea, 0x62, 0xc4, 0x3c, 0xce, 0x6d, 0x50, 0x42, 0x3d, 0x26, 0xb9, 0x94, 0xae, 0xc0, 0x87,
	0x1b, 0xc4, 0x3a, 0x80, 0x60, 0x0, 0x71, 0x75, 0xac, 0x15, 0x93, 0x4a, 0x6c, 0x1a, 0xd5, 0x7f,
	0x5b, 0xac, 0x3e, 0x6c, 0x97, 0xa5, 0x78, 0xaa, 0x14, 0x6a, 0xab, 0x66, 0xdd, 0x19, 0x79, 0xbf
};

static const unsigned char RSA_1024_Q[64] = {
	0xb0, 0x39, 0xbe, 0x31, 0x58, 0xa0, 0x5d, 0x26, 0x6d, 0x84, 0x8, 0xeb, 0x7c, 0x5b, 0xa4, 0x1c,
	0x45, 0x9f, 0x7e, 0x60, 0x27, 0xef, 0xed, 0x18, 0xc1, 0xf6, 0x81, 0x55, 0xbf, 0x66, 0x66, 0x17,
	0xae, 0x6c, 0xfd, 0x9, 0xee, 0xec, 0x7d, 0x87, 0x53, 0x1d, 0x3e, 0x40, 0xf9, 0x29, 0xa4, 0x33,
	0x3b, 0xfb, 0xaf, 0x28, 0x44, 0x6, 0x29, 0x14, 0xf7, 0xe4, 0x95, 0x1e, 0xc7, 0x6b, 0xf1, 0x31
};

static const unsigned char RSA_1024_D[128] = {
	0x59, 0xb6, 0xf5, 0x7, 0xc8, 0xb3, 0x2d, 0x6b, 0x6b, 0x42, 0xf0, 0x9e, 0x79, 0x9d, 0x5b, 0x22,
	0xb, 0xcf, 0x7f, 0x60, 0x70, 0x8e, 0xc6, 0x83, 0xc2, 0x86, 0x5e, 0x74, 0x10, 0xe5, 0xd5, 0x92,
	0x7d, 0x2e, 0x5f, 0xa6, 0xcf, 0x20, 0x1b, 0xbb, 0x5a, 0x2d, 0xfa, 0x35, 0x4a, 0x88, 0x9a, 0x74,
	0x40, 0x82, 0x8, 0xc1, 0x2a, 0x12, 0xd9, 0x46, 0x8a, 0x2c, 0x8, 0x11, 0x6a, 0x4b, 0x6d, 0xc0,
	0x4, 0x5a, 0xb4, 0xd6, 0x81, 0x60, 0x49, 0xbc, 0xf2, 0xf5, 0xaf, 0x94, 0x68, 0x75, 0x1f, 0x8f,
	0xe3, 0x9a, 0x0, 0x8b, 0xd8, 0x16, 0x11, 0xb, 0xb9, 0x2e, 0xe4, 0xd7, 0x6b, 0x5d, 0x7c, 0xf2,
	0x13, 0x50, 0x94, 0x92, 0x1d, 0x9a, 0xdc, 0x65, 0x4a, 0xd8, 0x34, 0x44, 0x60, 0x32, 0xb3, 0x49,
	0x68, 0x36, 0x24, 0x24, 0x3d, 0xe3, 0x19, 0x3, 0x5c, 0x70, 0xb9, 0x8c, 0xd5, 0x25, 0xff, 0xe1
};

static const unsigned char RSA_1024_E[4] = {
	0x0, 0x1, 0x0, 0x1
};

/* RSA 2048 => N, P, Q, D, E element */
static const unsigned char RSA_2048_N[256] = {
	0xa4, 0x20, 0x92, 0xb6, 0x12, 0x5a, 0x9a, 0xca, 0x80, 0x6c, 0x53, 0xd7, 0xd1, 0x3d, 0x4, 0x6a,
	0xc1, 0x97, 0x72, 0xb, 0xbd, 0xf5, 0xd4, 0x60, 0x85, 0x5c, 0xbf, 0x95, 0xa0, 0x8a, 0xd8, 0x22,
	0x17, 0x99, 0xe6, 0xc9, 0xd0, 0xb6, 0xa3, 0x3a, 0x19, 0xb1, 0xcf, 0x2e, 0x20, 0x73, 0x21, 0xa8,
	0x65, 0xb4, 0xb5, 0xe5, 0x37, 0x6, 0x6c, 0x8c, 0x58, 0xaa, 0xbb, 0x67, 0x62, 0xee, 0x20, 0x1b,
	0x9c, 0xf5, 0xba, 0x1b, 0x5f, 0x3d, 0xb6, 0x28, 0x4e, 0x39, 0xad, 0x8f, 0x5e, 0x54, 0x4f, 0x21,
	0x3f, 0x5f, 0x51, 0xdd, 0x24, 0x38, 0x27, 0x74, 0xec, 0xd0, 0x0, 0xfc, 0xa3, 0x79, 0xe4, 0x8c,
	0x7a, 0xfd, 0xff, 0x75, 0x12, 0x62, 0x4a, 0xc, 0x59, 0xb6, 0x8e, 0x89, 0xca, 0xbb, 0x9c, 0xad,
	0xd2, 0x3d, 0x79, 0x4e, 0x8e, 0x2a, 0x48, 0xd7, 0x85, 0x1d, 0x27, 0xf0, 0xf9, 0x40, 0x7f, 0x63,
	0xba, 0x79, 0x37, 0xbd, 0x1, 0x7b, 0x1d, 0x4c, 0x71, 0x31, 0x7d, 0x1f, 0x30, 0x17, 0x16, 0xb6,
	0x87, 0x11, 0xea, 0x8c, 0xdc, 0xa3, 0x28, 0x92, 0x34, 0x21, 0xed, 0xac, 0xff, 0xe5, 0xf6, 0x46,
	0xfc, 0x1f, 0x14, 0xde, 0xc5, 0xfd, 0x49, 0x1e, 0x57, 0x5e, 0x1c, 0x79, 0x2a, 0x9d, 0xe4, 0xfc,
	0x37, 0xd7, 0x84, 0xa2, 0x73, 0xa6, 0xba, 0xb, 0x57, 0xb, 0x39, 0x8a, 0xee, 0x67, 0xaf, 0x3e,
	0xf0, 0xd1, 0xbe, 0xf1, 0x80, 0x3b, 0x22, 0x61, 0xb1, 0x3c, 0xd3, 0xb3, 0xde, 0x1d, 0xd, 0xaf,
	0xc7, 0x6e, 0x10, 0x5e, 0xd9, 0xda, 0xb3, 0x40, 0x6, 0x93, 0x7, 0x84, 0x53, 0x84, 0xc, 0xec,
	0x14, 0xfa, 0x5e, 0x30, 0xb0, 0xc, 0xaf, 0xf9, 0x48, 0x98, 0xab, 0x78, 0xac, 0x39, 0x73, 0x70,
	0x73, 0x79, 0x63, 0x90, 0x36, 0x25, 0x84, 0xd2, 0xd3, 0x4a, 0x78, 0x11, 0xb5, 0x9f, 0x27, 0xdb
};

static const unsigned char RSA_2048_P[128] = {
	0xe1, 0x3d, 0x48, 0x68, 0xa1, 0x7, 0xbb, 0xc8, 0x43, 0xed, 0xea, 0x9a, 0xb5, 0xd7, 0x42, 0xbc,
	0x33, 0xa8, 0xba, 0xf1, 0xa9, 0xd5, 0x62, 0xeb, 0x1c, 0x12, 0xbc, 0xca, 0xab, 0x2e, 0xd2, 0x77,
	0x2b, 0x3f, 0x8a, 0x68, 0x54, 0x12, 0x3, 0x7e, 0x34, 0x7e, 0x18, 0x62, 0x7a, 0x86, 0x3d, 0x74,
	0x44, 0xad, 0x4d, 0x4c, 0x49, 0xdc, 0x53, 0x9e, 0xe3, 0x5b, 0x93, 0x5e, 0x68, 0x1b, 0xeb, 0x70,
	0x52, 0x54, 0x72, 0x93, 0x8f, 0x66, 0xae, 0x13, 0xd, 0x9a, 0x6d, 0x5a, 0x7c, 0x75, 0x50, 0x77,
	0xf, 0xd8, 0x55, 0x52, 0x82, 0xb, 0xdf, 0x3a, 0x86, 0x92, 0x0, 0x3, 0xcc, 0x7a, 0xdb, 0x8b,
	0x28, 0x5, 0x83, 0x50, 0x48, 0x2, 0x7c, 0x88, 0xff, 0x67, 0x9c, 0x75, 0xc0, 0x46, 0x11, 0x71,
	0xc5, 0x96, 0xa9, 0xc4, 0x1, 0xab, 0x6d, 0x77, 0x23, 0x32, 0xf6, 0x6a, 0x76, 0x66, 0xa, 0xfd
};

static const unsigned char RSA_2048_Q[128] = {
	0xba, 0x8a, 0xb7, 0x10, 0x27, 0xe, 0x3c, 0x69, 0x9a, 0x9c, 0xb6, 0x63, 0x48, 0x93, 0xc6, 0xb,
	0x6, 0xa, 0xbe, 0x2c, 0x3d, 0x17, 0x8c, 0xbe, 0x8c, 0xee, 0x8, 0xb, 0x4c, 0xfd, 0x3c, 0xf,
	0xcc, 0x1d, 0xde, 0x30, 0x23, 0xd, 0x55, 0x12, 0xfd, 0xf4, 0xc8, 0x86, 0x29, 0x3e, 0xe7, 0x13,
	0xe6, 0xba, 0xdd, 0x16, 0xa4, 0x2a, 0x35, 0xb8, 0xb2, 0x5b, 0x7d, 0xac, 0x99, 0xda, 0x77, 0xf0,
	0x10, 0x33, 0x45, 0xe2, 0x27, 0x98, 0x88, 0x24, 0x26, 0x99, 0x3c, 0xf, 0x40, 0x28, 0x49, 0xf2,
	0xb0, 0xe2, 0xd4, 0xce, 0x4b, 0xfd, 0xc, 0x6c, 0xbd, 0x10, 0x46, 0x78, 0xb1, 0x91, 0x2, 0x27,
	0x46, 0xeb, 0xa4, 0xe6, 0xd6, 0xb6, 0xeb, 0xb8, 0xd2, 0x30, 0xf3, 0x11, 0x86, 0xba, 0xd8, 0x64,
	0xb1, 0xd5, 0x49, 0xa2, 0x62, 0x54, 0xd3, 0xfe, 0xb1, 0x7c, 0xb0, 0x28, 0xcc, 0x84, 0x91, 0xb7
};

static const unsigned char RSA_2048_D[256] = {
	0x0, 0x6a, 0x6c, 0xb4, 0xb5, 0x5b, 0x31, 0x65, 0x2d, 0xea, 0x18, 0x54, 0x45, 0x9d, 0x67, 0xf3,
	0x75, 0x46, 0x12, 0xed, 0xe0, 0xaf, 0x4c, 0xb8, 0x69, 0xde, 0x10, 0x46, 0x2a, 0xbf, 0xef, 0x48,
	0x36, 0xd3, 0x16, 0xf8, 0x8f, 0xe4, 0xc6, 0x89, 0x11, 0x23, 0x98, 0x28, 0xbf, 0xc0, 0x4a, 0xe7,
	0x88, 0x4a, 0x6a, 0xe3, 0x87, 0xbe, 0x26, 0x6c, 0x3c, 0x95, 0x42, 0x20, 0x42, 0xe9, 0xe3, 0x7e,
	0xee, 0x68, 0xd8, 0xed, 0xd4, 0xd1, 0xed, 0x32, 0x30, 0xf0, 0x88, 0x76, 0x2, 0x81, 0x28, 0x2a,
	0x27, 0x64, 0xf0, 0x6a, 0x24, 0xfb, 0x57, 0x6e, 0x3e, 0x63, 0x50, 0x7d, 0x53, 0x54, 0xad, 0xb5,
	0x85, 0x62, 0x3b, 0x51, 0x6a, 0x98, 0x81, 0x23, 0x82, 0xde, 0xa9, 0x81, 0xc3, 0xd7, 0xb1, 0xcf,
	0xe6, 0xe6, 0x6c, 0xf6, 0x3b, 0xf9, 0xf3, 0x71, 0x48, 0x4f, 0x8, 0x98, 0xdd, 0xa8, 0xc2, 0x29,
	0xd7, 0x76, 0xf, 0x74, 0x6c, 0xc8, 0xca, 0xcd, 0x44, 0x6d, 0xd3, 0xc4, 0xe9, 0xc1, 0x4b, 0xcf,
	0xbd, 0x5c, 0x6d, 0xe1, 0x20, 0x12, 0x34, 0x16, 0xb2, 0xb3, 0x84, 0xcc, 0xf6, 0xa2, 0xb, 0xea,
	0x3a, 0x98, 0xda, 0xfc, 0xda, 0x9a, 0x49, 0x4f, 0xb2, 0x36, 0x3e, 0x52, 0x61, 0x65, 0xf, 0x27,
	0xbc, 0x18, 0x54, 0x1c, 0x31, 0x14, 0x74, 0xcb, 0x1f, 0xc4, 0x3c, 0xce, 0x6, 0x25, 0x4b, 0x51,
	0xe6, 0xfe, 0x5d, 0x1, 0xd7, 0x42, 0xa5, 0x98, 0x7d, 0xf4, 0x95, 0xfc, 0xd6, 0x14, 0xe2, 0x8f,
	0xdc, 0xd8, 0x7b, 0x28, 0xd1, 0x12, 0xd8, 0xf4, 0x94, 0x19, 0xd4, 0x3, 0x57, 0x11, 0x14, 0xdd,
	0x8a, 0x84, 0x1f, 0x74, 0xe0, 0x5f, 0x5b, 0xa1, 0x25, 0x56, 0x4, 0xbc, 0x19, 0xcb, 0x88, 0xdd,
	0xb0, 0xfb, 0xbf, 0xba, 0xfb, 0x63, 0x48, 0xc6, 0x65, 0x86, 0xb2, 0xdd, 0x25, 0x21, 0x3b, 0xf1
};

static const unsigned char RSA_2048_E[4] = {
	0x0, 0x1, 0x0, 0x1
};

/* RSA 3072 => N, P, Q, D, E element */
static const unsigned char RSA_3072_N[384] = {
	0x8b, 0xb8, 0x8b, 0xae, 0x74, 0x26, 0x84, 0x4d, 0xdb, 0xe3, 0xd0, 0xaa, 0xd8, 0xcd, 0xf3, 0x46,
	0xf2, 0xf4, 0x2a, 0xb1, 0x4a, 0x6c, 0x5, 0x80, 0xf2, 0xb, 0x69, 0x76, 0xed, 0xc, 0xc7, 0xbb,
	0xdb, 0x3d, 0x8f, 0x66, 0x13, 0x26, 0x52, 0xb0, 0x57, 0xac, 0xf7, 0x2, 0x8c, 0x99, 0x1, 0xfc,
	0x6e, 0xe6, 0xdf, 0xc9, 0x99, 0x11, 0x35, 0x81, 0xaa, 0xa1, 0xc8, 0xc6, 0x51, 0x62, 0x46, 0x1b,
	0x3a, 0x84, 0xb1, 0xda, 0xe1, 0x9e, 0x3, 0x22, 0x9d, 0x2d, 0x91, 0x94, 0x75, 0x7a, 0x96, 0x10,
	0x14, 0x1a, 0x64, 0x96, 0x16, 0xe, 0xdf, 0x19, 0x14, 0xe7, 0xf1, 0x9d, 0x8d, 0x72, 0x37, 0xe5,
	0xe0, 0x92, 0x29, 0xc1, 0xa4, 0xfb, 0x49, 0xd0, 0x1e, 0xca, 0x1c, 0xcd, 0xc7, 0x81, 0x91, 0xa8,
	0xba, 0xb5, 0x36, 0x71, 0x64, 0xbe, 0xaf, 0xfa, 0x71, 0x1f, 0xff, 0xc4, 0x5c, 0xd4, 0x82, 0x7c,
	0x80, 0x88, 0x63, 0x61, 0x7e, 0xd5, 0x26, 0xe5, 0xf1, 0x14, 0x45, 0xf3, 0xca, 0x24, 0xfb, 0xb7,
	0x63, 0x3e, 0x2b, 0xab, 0x81, 0xc, 0x51, 0x9b, 0x60, 0x6a, 0x2e, 0xd5, 0x40, 0x4f, 0x6, 0x81,
	0xe6, 0x96, 0x1a, 0xd8, 0x40, 0xfe, 0xa9, 0x6f, 0x52, 0x75, 0xa5, 0x95, 0x24, 0x4f, 0x27, 0xcc,
	0x77, 0x7, 0xe4, 0xdb, 0x32, 0xfc, 0xaf, 0x8a, 0x30, 0x2a, 0x2c, 0xb6, 0xa4, 0x4f, 0x2f, 0x43,
	0x4f, 0xc6, 0x3d, 0x3c, 0x39, 0x87, 0xe1, 0x69, 0x53, 0x72, 0x82, 0xad, 0x3b, 0x83, 0xed, 0xa4,
	0x5c, 0x44, 0x38, 0xff, 0xeb, 0x33, 0xe3, 0x1, 0xa8, 0x7e, 0x58, 0x1f, 0x91, 0x55, 0x65, 0xef,
	0x8c, 0x1b, 0xed, 0x5f, 0xcb, 0x80, 0xca, 0xd2, 0x4f, 0x61, 0x47, 0x17, 0xc, 0x65, 0xc7, 0x42,
	0xb0, 0x3b, 0x49, 0xf9, 0x35, 0x6f, 0xe9, 0x63, 0x8e, 0x37, 0x43, 0x81, 0xeb, 0xe0, 0x8a, 0x1c,
	0x33, 0x55, 0x41, 0x85, 0x91, 0x92, 0xf3, 0x82, 0xce, 0x6c, 0xda, 0xce, 0xd, 0x41, 0x6, 0x42,
	0x44, 0x30, 0xbc, 0xd6, 0x4a, 0x74, 0x75, 0x78, 0xbb, 0x8b, 0xfb, 0x6f, 0xc0, 0x8f, 0x79, 0x77,
	0x2e, 0x54, 0x89, 0x79, 0x31, 0x89, 0x20, 0x66, 0x25, 0x17, 0x17, 0x6a, 0x9d, 0xe7, 0xad, 0x90,
	0x16, 0x4c, 0x92, 0x1, 0xeb, 0x2a, 0xab, 0x34, 0x44, 0x57, 0x41, 0xe1, 0x2d, 0x24, 0x92, 0xd0,
	0x97, 0xbd, 0x81, 0xa0, 0xfd, 0x9a, 0x97, 0x7a, 0xa8, 0x4b, 0x61, 0x74, 0x5f, 0x9b, 0x97, 0x9c,
	0x75, 0x75, 0xed, 0xc9, 0x3b, 0x56, 0x9b, 0x1a, 0xaa, 0xa, 0x71, 0x3c, 0x97, 0x19, 0x78, 0x29,
	0xfe, 0xcf, 0xf4, 0x29, 0xfb, 0x54, 0xfa, 0xf2, 0xd1, 0xf8, 0xaf, 0x7d, 0xd5, 0x66, 0xdb, 0x8f,
	0x92, 0xd6, 0xd4, 0x55, 0x9e, 0x55, 0x91, 0x22, 0x21, 0x1a, 0x53, 0xd4, 0x68, 0x4c, 0x3f, 0x7
};

static const unsigned char RSA_3072_P[192] = {
	0xf1, 0x7a, 0x48, 0xb8, 0x9e, 0x80, 0xac, 0xcd, 0x6e, 0x1d, 0x96, 0x53, 0x12, 0x83, 0xfd, 0x0,
	0x19, 0xeb, 0x6c, 0xa2, 0x5a, 0xed, 0x2d, 0x9b, 0x45, 0x3f, 0x2a, 0x97, 0xf7, 0x48, 0x7b, 0xa6,
	0x17, 0x37, 0xdd, 0x74, 0x73, 0x6c, 0x8, 0x5f, 0xb9, 0xb8, 0x49, 0xc1, 0xf7, 0xc, 0x1c, 0xf5,
	0x58, 0xde, 0x40, 0x29, 0xb1, 0xac, 0x90, 0x74, 0xd3, 0x38, 0x99, 0x4a, 0xce, 0x9e, 0x8d, 0xe2,
	0xc1, 0x7a, 0xb0, 0xf0, 0xcb, 0xfb, 0xc5, 0x36, 0xcb, 0x43, 0x38, 0xae, 0xe6, 0x82, 0xd, 0x19,
	0x15, 0x6a, 0x5a, 0xc7, 0xde, 0x4, 0xaf, 0x44, 0x17, 0x50, 0xe0, 0xe7, 0x28, 0x8, 0x78, 0x77,
	0xfa, 0xed, 0xd7, 0x89, 0x9c, 0x71, 0x1c, 0x82, 0x21, 0xb7, 0xc5, 0xc9, 0x2b, 0x54, 0x2f, 0x62,
	0x8a, 0x51, 0x4b, 0xa6, 0xf7, 0xf9, 0x79, 0xc5, 0xa1, 0x1f, 0x24, 0xc6, 0x85, 0x81, 0x76, 0xc9,
	0x49, 0x6a, 0xf3, 0x89, 0x93, 0xec, 0x80, 0xae, 0xe9, 0x54, 0x6d, 0x9f, 0x50, 0x29, 0x48, 0xb5,
	0x14, 0x22, 0x15, 0xe8, 0x95, 0x82, 0x53, 0x36, 0x3c, 0x7f, 0x2b, 0xe5, 0xf3, 0xeb, 0x98, 0xc7,
	0x94, 0x41, 0x84, 0xfb, 0x2a, 0xf7, 0x61, 0x28, 0x4e, 0xec, 0x9a, 0x2d, 0x54, 0xb9, 0xac, 0x52,
	0x0, 0x9d, 0x61, 0x55, 0xcd, 0x13, 0x74, 0x80, 0x5c, 0xb9, 0x31, 0xb9, 0xe5, 0x56, 0x5f, 0x9
};

static const unsigned char RSA_3072_Q[192] = {
	0x94, 0x1f, 0xa5, 0x34, 0xd, 0x32, 0xd7, 0xd3, 0xc6, 0x1b, 0x5c, 0x62, 0x78, 0xb, 0x40, 0x76,
	0xb3, 0x7d, 0xd6, 0xc7, 0x64, 0x3a, 0xda, 0x10, 0x59, 0x4, 0x54, 0xf9, 0x32, 0xa, 0xdf, 0x80,
	0xaf, 0x98, 0x90, 0x27, 0x1e, 0xe7, 0x29, 0x21, 0x7, 0x66, 0x48, 0x11, 0xff, 0xc5, 0xd7, 0x65,
	0x3a, 0x0, 0x83, 0x44, 0x9c, 0xb1, 0x9c, 0x53, 0x2, 0x37, 0x40, 0xc7, 0x27, 0x49, 0xb0, 0xd8,
	0xac, 0xde, 0x30, 0xd5, 0xd5, 0xac, 0xac, 0xcd, 0xca, 0x29, 0xd8, 0x86, 0x8a, 0x1f, 0x6b, 0x66,
	0xdd, 0xfa, 0x79, 0xe, 0xc2, 0xf, 0xfe, 0xf2, 0x69, 0x55, 0xef, 0x61, 0x80, 0x63, 0x63, 0xbd,
	0x17, 0x56, 0xaa, 0xaa, 0xc6, 0xe7, 0xbc, 0x8f, 0x2, 0x49, 0xaa, 0x8e, 0xed, 0xa3, 0x62, 0xb9,
	0xe3, 0x1b, 0x1b, 0x62, 0x92, 0x72, 0x84, 0x0, 0x6, 0x5a, 0xba, 0x8f, 0x8f, 0xca, 0x6, 0xb8,
	0xb6, 0xa3, 0x85, 0xc7, 0xaa, 0x6c, 0x6, 0x69, 0x8b, 0x90, 0xd2, 0x2, 0x27, 0x84, 0x48, 0xc,
	0xda, 0xc0, 0x8e, 0x90, 0x37, 0x6a, 0x59, 0x58, 0xdb, 0xcc, 0x3a, 0xc, 0xd2, 0x95, 0xdb, 0x41,
	0xa8, 0x73, 0x7e, 0x89, 0x53, 0xab, 0x47, 0x2a, 0xd5, 0x88, 0x32, 0x79, 0xfe, 0xef, 0xac, 0xcf,
	0xf5, 0x2, 0x66, 0xeb, 0xe6, 0x13, 0x50, 0x9c, 0xb9, 0xd6, 0x8b, 0x3, 0x1a, 0xa5, 0x21, 0x8f
};

static const unsigned char RSA_3072_D[384] = {
	0x74, 0x24, 0x42, 0x50, 0x10, 0x92, 0xd7, 0xd5, 0x94, 0x9c, 0x29, 0x9f, 0x6a, 0xba, 0xbf, 0xa7,
	0xd1, 0x5a, 0xef, 0x86, 0x12, 0x13, 0xfa, 0xfb, 0x35, 0xb8, 0x10, 0xc1, 0xdf, 0xc8, 0x88, 0xda,
	0xfa, 0x22, 0x90, 0xe9, 0xcb, 0xaf, 0x46, 0x7a, 0xf9, 0x56, 0x78, 0xb9, 0x70, 0xbf, 0xdb, 0x6b,
	0xc7, 0x90, 0x38, 0xa3, 0xee, 0x8d, 0xe4, 0x89, 0x55, 0x9a, 0x48, 0x37, 0xb9, 0xfc, 0xd3, 0xc3,
	0xdc, 0x7f, 0xe3, 0xb, 0xcc, 0x11, 0xba, 0xf, 0x72, 0xd2, 0x27, 0x3a, 0x5d, 0xf1, 0x39, 0x7e,
	0x42, 0x7, 0xb2, 0x67, 0x24, 0xc, 0xd6, 0x9c, 0x95, 0xc9, 0x3c, 0x9, 0xb8, 0x43, 0x22, 0x7d,
	0xfe, 0x8f, 0xe1, 0xf, 0xeb, 0xa1, 0x4a, 0xb9, 0x2a, 0x6e, 0xdd, 0x44, 0x9c, 0xbb, 0x72, 0xa5,
	0xec, 0x15, 0xa8, 0x1c, 0xd8, 0x1e, 0xbe, 0x4f, 0x92, 0xeb, 0x83, 0x82, 0xe9, 0x9b, 0x68, 0xa0,
	0x2f, 0x83, 0xb0, 0x0, 0xa2, 0x1a, 0x72, 0xcc, 0x1e, 0xfa, 0xb8, 0x2f, 0x2f, 0x70, 0x50, 0xa1,
	0x1f, 0x68, 0xd5, 0x8a, 0x29, 0xaa, 0x60, 0xc7, 0xa4, 0x7c, 0x7f, 0x53, 0x9a, 0xb2, 0x55, 0xf9,
	0x73, 0x0, 0x81, 0x6e, 0x13, 0x90, 0xdc, 0xad, 0x1, 0xc1, 0x73, 0x93, 0xa6, 0xeb, 0xf9, 0x6c,
	0x37, 0xe1, 0xa2, 0xf6, 0x26, 0xca, 0xee, 0xec, 0x12, 0x9f, 0x6c, 0x2d, 0xa2, 0x25, 0x84, 0x65,
	0xce, 0xb5, 0xc8, 0x73, 0x9b, 0xb4, 0xd4, 0x2f, 0x31, 0xed, 0x7a, 0x63, 0xed, 0x7f, 0x68, 0x57,
	0x66, 0x71, 0x52, 0x45, 0xb3, 0x75, 0x63, 0xac, 0x80, 0xb2, 0x6b, 0xc2, 0xec, 0x68, 0xe, 0x28,
	0xd7, 0xff, 0xab, 0x44, 0x24, 0x37, 0x68, 0x43, 0xe7, 0xda, 0x41, 0xac, 0x72, 0xea, 0x3f, 0x1d,
	0xdd, 0x12, 0x45, 0x70, 0x7f, 0x25, 0x3a, 0x3f, 0xc3, 0x78, 0x57, 0x87, 0xce, 0xd1, 0xc7, 0x6e,
	0xb8, 0x30, 0x5, 0x32, 0xc5, 0x61, 0x8c, 0xa4, 0xac, 0xa2, 0xcb, 0x24, 0x5, 0xc5, 0x87, 0x63,
	0xe8, 0x1f, 0xa8, 0x1d, 0xa5, 0xb5, 0x1a, 0x0, 0x4e, 0xce, 0xa2, 0x71, 0x4b, 0xda, 0x86, 0xe5,
	0x26, 0x48, 0x98, 0x92, 0x34, 0x46, 0xe3, 0x74, 0xa0, 0x83, 0x2c, 0x2e, 0xf3, 0xbc, 0x57, 0x45,
	0x6c, 0x32, 0x72, 0xe5, 0xa6, 0x1d, 0xba, 0x32, 0xc1, 0x48, 0x31, 0x9a, 0xe7, 0x86, 0xf6, 0xf4,
	0x2e, 0x98, 0x3b, 0x73, 0x76, 0xcb, 0x66, 0xad, 0xa, 0x86, 0xb2, 0x45, 0xb, 0xaf, 0xcb, 0x98,
	0xa8, 0xd7, 0x13, 0xd1, 0x3d, 0x6, 0xe7, 0x58, 0xb3, 0x1d, 0x38, 0x37, 0xf2, 0xa1, 0xfa, 0x84,
	0x74, 0x75, 0x4a, 0x66, 0x75, 0x62, 0x11, 0xd6, 0x53, 0xb8, 0xd6, 0xbd, 0x72, 0x79, 0x62, 0x4a,
	0xd5, 0xad, 0xa5, 0x67, 0x85, 0x4e, 0x90, 0x1e, 0xfc, 0xa5, 0x39, 0x75, 0x26, 0xac, 0x3f, 0xb1
};

static const unsigned char RSA_3072_E[4] = {
	0x0, 0x1, 0x0, 0x1
};

/* RSA 4096 => N, P, Q, D, E element */
static const unsigned char RSA_4096_N[512] = {
	0x8f, 0x26, 0x98, 0x0, 0xd6, 0xaa, 0xc, 0xd9, 0x6d, 0x24, 0xf9, 0x39, 0x9e, 0xe1, 0x65, 0x76,
	0xd, 0x5d, 0xbd, 0xea, 0x64, 0x5b, 0xac, 0x26, 0x7, 0x50, 0xc8, 0xd7, 0x75, 0x8d, 0x77, 0x90,
	0xf7, 0x46, 0xfe, 0x25, 0x90, 0x85, 0x5b, 0x1a, 0x3c, 0x65, 0x90, 0xd3, 0x9, 0xb2, 0xed, 0xa0,
	0x1a, 0xae, 0x21, 0x84, 0x6e, 0x90, 0xf3, 0x4d, 0x63, 0x45, 0x89, 0x7, 0x70, 0x85, 0xf, 0xbe,
	0xe4, 0x65, 0xc5, 0xd3, 0x7b, 0xc6, 0x56, 0x6d, 0x50, 0x4d, 0x19, 0xf4, 0x70, 0x79, 0x7e, 0xe1,
	0x60, 0x81, 0x2e, 0xd8, 0xcc, 0x1b, 0x3c, 0x9c, 0xe3, 0x4c, 0xbe, 0x20, 0xfa, 0xb9, 0x94, 0x6c,
	0x88, 0xe3, 0xc1, 0x4a, 0x3b, 0x54, 0xca, 0x4d, 0xcf, 0x28, 0xa7, 0xf, 0xea, 0x7a, 0x6e, 0x79,
	0xa5, 0xc2, 0x4b, 0x58, 0xcb, 0xa0, 0xd1, 0xe9, 0x41, 0x1d, 0x22, 0x56, 0xdb, 0x21, 0x91, 0x88,
	0x25, 0x6b, 0xb9, 0xc5, 0xe7, 0x10, 0x3a, 0xc4, 0xf0, 0xfe, 0xaf, 0xfb, 0xea, 0xb6, 0x54, 0x35,
	0x22, 0x41, 0x50, 0x5f, 0x1c, 0xa6, 0x7, 0x75, 0xce, 0xf3, 0xe4, 0xb8, 0x2a, 0x2a, 0x9f, 0x5f,
	0xc3, 0x2b, 0xf5, 0xda, 0x59, 0x34, 0x99, 0xbd, 0x6f, 0x42, 0x3, 0x56, 0x7, 0x7b, 0xff, 0x9b,
	0xc1, 0xec, 0x4c, 0xfc, 0xb2, 0x85, 0xa9, 0xf2, 0xd5, 0xf3, 0x68, 0x9d, 0x94, 0xcc, 0xa5, 0x12,
	0xdb, 0xf8, 0x49, 0x33, 0x27, 0x9f, 0xb9, 0x38, 0x41, 0xa6, 0x65, 0x98, 0x2e, 0x48, 0xbc, 0xe4,
	0x75, 0x23, 0x1f, 0xa4, 0x4f, 0x2d, 0xc0, 0x21, 0x87, 0x1a, 0x5f, 0x9c, 0xcf, 0x3b, 0xb0, 0xf0,
	0x45, 0xbf, 0x29, 0x96, 0xb3, 0x4, 0x86, 0xfe, 0x4b, 0x83, 0x1b, 0xa9, 0x17, 0x24, 0xeb, 0xc3,
	0x25, 0x75, 0x80, 0x30, 0xbe, 0x20, 0x8e, 0x8, 0xee, 0x8c, 0x3, 0xc3, 0xab, 0x18, 0x9f, 0xd7,
	0xd6, 0x19, 0xcb, 0x41, 0x5d, 0xd7, 0x96, 0xb0, 0x7c, 0x97, 0xd4, 0x76, 0x9e, 0x5e, 0x29, 0x64,
	0x11, 0x3e, 0xf6, 0x51, 0x1e, 0x20, 0x62, 0x11, 0xd, 0xa8, 0xa, 0xa3, 0xb, 0xf1, 0x9c, 0x4,
	0xf, 0x36, 0x3b, 0x46, 0xd0, 0x7e, 0x56, 0x94, 0x50, 0xd2, 0xb4, 0xeb, 0x5a, 0xe3, 0x74, 0x96,
	0xc0, 0x75, 0x90, 0x13, 0x63, 0x26, 0xb4, 0x49, 0x40, 0x40, 0x46, 0xfc, 0x6a, 0xa5, 0x9a, 0xc9,
	0x91, 0x83, 0xc3, 0xd9, 0xcf, 0x63, 0x93, 0xc1, 0x5f, 0x42, 0x78, 0x71, 0x88, 0x21, 0x1, 0x1a,
	0xe9, 0xda, 0x76, 0xb3, 0xac, 0x86, 0x30, 0x5c, 0x16, 0xb9, 0x35, 0x16, 0x21, 0x17, 0x93, 0x59,
	0x43, 0xf7, 0x6e, 0xcc, 0xc9, 0x67, 0xd0, 0x6c, 0x77, 0xef, 0xd6, 0xfb, 0xfe, 0x1e, 0xdc, 0x37,
	0x9a, 0xef, 0xec, 0x40, 0x66, 0xb7, 0x52, 0xa6, 0x12, 0xe8, 0x2b, 0x3, 0x88, 0xec, 0x79, 0x4f,
	0x4f, 0x7e, 0xb9, 0xf7, 0x11, 0xdb, 0x6f, 0xe8, 0xf4, 0xfa, 0xca, 0x48, 0x6a, 0xfe, 0x76, 0x5c,
	0x3a, 0x63, 0xef, 0xd, 0x47, 0x88, 0x58, 0xe1, 0xff, 0x5, 0x7b, 0xe5, 0xe0, 0x71, 0x1a, 0xf6,
	0x27, 0xe9, 0x35, 0xdf, 0x76, 0x30, 0xbb, 0x51, 0x2b, 0xc7, 0x8c, 0x34, 0x42, 0x12, 0x33, 0xe7,
	0xce, 0x7a, 0x2f, 0xf6, 0x31, 0xaa, 0x57, 0xf8, 0x50, 0xd7, 0x95, 0x95, 0x26, 0x3f, 0xfb, 0xe0,
	0x4a, 0xc1, 0xa2, 0xfc, 0x1, 0x6, 0xe2, 0x3e, 0xca, 0xc1, 0x17, 0x98, 0xbc, 0x51, 0x45, 0x30,
	0x4, 0x4f, 0xcb, 0xd9, 0x71, 0x88, 0x9c, 0x4f, 0xa3, 0x37, 0x25, 0xb0, 0x74, 0x71, 0x22, 0x5a,
	0x80, 0x41, 0xca, 0x5c, 0x79, 0x19, 0x61, 0xf6, 0x9b, 0x26, 0x6c, 0xfa, 0x2c, 0xb0, 0xee, 0xe4,
	0xd7, 0x4c, 0x90, 0xaa, 0xea, 0x70, 0x26, 0x58, 0x6e, 0xa0, 0xed, 0x85, 0x3, 0xd3, 0x1b, 0x3b
};

static const unsigned char RSA_4096_P[256] = {
	0xf7, 0xd0, 0x2a, 0xb9, 0xf, 0xe9, 0xa, 0x33, 0x80, 0xec, 0xe0, 0x88, 0x1d, 0x82, 0x37, 0xe2,
	0x3f, 0x6d, 0xd2, 0x8d, 0x99, 0x13, 0xf5, 0x6c, 0xa1, 0x61, 0x6, 0xaa, 0xbd, 0xdc, 0xe7, 0xf6,
	0xed, 0x1b, 0xfe, 0x31, 0x0, 0xba, 0x73, 0xc8, 0x54, 0x1, 0xf6, 0x64, 0xab, 0x65, 0x2d, 0xf1,
	0x1d, 0x37, 0xd7, 0xf, 0x98, 0x6c, 0x34, 0xad, 0x5f, 0x5e, 0xdc, 0xf8, 0x38, 0xaa, 0x94, 0x6e,
	0x57, 0xaf, 0xb, 0x9, 0xcc, 0x15, 0x6f, 0xdf, 0x80, 0x2e, 0xa5, 0xdc, 0xa1, 0x34, 0x9c, 0xff,
	0xec, 0x50, 0x1c, 0x60, 0x6b, 0x4f, 0xe7, 0x50, 0x3b, 0xdf, 0xdb, 0x27, 0x93, 0x47, 0xed, 0x14,
	0xc, 0x42, 0x71, 0x5d, 0x6f, 0x48, 0x23, 0xb8, 0x9d, 0x5e, 0x61, 0x5b, 0xfe, 0xb1, 0xc8, 0xd7,
	0xd7, 0x6, 0x73, 0x35, 0xd8, 0xc2, 0xdc, 0x6a, 0x62, 0xa4, 0x91, 0x1, 0x6a, 0xbf, 0x3f, 0xab,
	0x9f, 0x66, 0x4e, 0x58, 0x7a, 0x2e, 0xd1, 0x8c, 0xbb, 0x84, 0xf, 0x81, 0x52, 0xf8, 0x42, 0x66,
	0xe5, 0x61, 0xa9, 0xcc, 0x74, 0x9a, 0x54, 0x1a, 0x6e, 0x31, 0xd6, 0x95, 0xb7, 0x79, 0xe0, 0xf8,
	0xe7, 0xdb, 0x77, 0x6b, 0x8f, 0xdf, 0xc6, 0x7e, 0x81, 0x22, 0xb9, 0xa9, 0x16, 0xec, 0xd4, 0x6d,
	0x53, 0xcb, 0x97, 0x8d, 0x89, 0xca, 0x19, 0x98, 0xc4, 0x97, 0xec, 0x29, 0x65, 0x8c, 0xbc, 0x2d,
	0xeb, 0x75, 0xff, 0xcb, 0x85, 0xa8, 0xe5, 0x5f, 0x50, 0xaf, 0x33, 0xae, 0x1e, 0xda, 0x82, 0xae,
	0xdd, 0x59, 0xb2, 0xf9, 0x32, 0x65, 0x2e, 0x6e, 0xa0, 0x74, 0x62, 0xb, 0xd, 0xc, 0x1e, 0x37,
	0x71, 0xcd, 0x7e, 0x5e, 0xa8, 0x6c, 0x7, 0xc4, 0x23, 0x82, 0x34, 0xfd, 0xf, 0x6b, 0x2c, 0xaf,
	0xab, 0x5b, 0xcd, 0xf6, 0x26, 0xe0, 0x2b, 0xa7, 0x8, 0x2, 0x3d, 0x3c, 0xf8, 0x3c, 0x6c, 0x47
};

static const unsigned char RSA_4096_Q[256] = {
	0x93, 0xe1, 0x43, 0xad, 0x13, 0xa5, 0xcc, 0x22, 0x14, 0x2f, 0xd6, 0xa5, 0xc4, 0xcf, 0x23, 0x3b,
	0x8b, 0xbc, 0xc0, 0x55, 0x7f, 0x94, 0xc6, 0xb, 0xca, 0x1d, 0x4e, 0xcb, 0xcc, 0x49, 0x70, 0xca,
	0x29, 0xf7, 0x9c, 0x81, 0x4f, 0x5, 0x93, 0xfd, 0x78, 0x31, 0xf9, 0xd4, 0x5c, 0x93, 0x2e, 0x63,
	0x26, 0xa1, 0x4a, 0x1a, 0x63, 0x20, 0xf, 0x5c, 0xc0, 0x8a, 0x3b, 0xee, 0xaf, 0x62, 0xdf, 0x59,
	0x75, 0xfa, 0x5b, 0x39, 0xb3, 0xca, 0x34, 0xe5, 0x91, 0xc7, 0x70, 0xea, 0xe4, 0xc6, 0x26, 0x63,
	0x35, 0x9a, 0x8d, 0x43, 0x48, 0x18, 0x7, 0x72, 0x81, 0xc1, 0x6f, 0xbf, 0x8e, 0x55, 0x7, 0xd0,
	0xd7, 0xe7, 0x6e, 0x57, 0x3b, 0xf4, 0xcc, 0xb3, 0xef, 0xfd, 0x8f, 0x43, 0xa, 0x5, 0x53, 0x47,
	0xed, 0x27, 0x7c, 0xe7, 0xb, 0xa0, 0x8d, 0x63, 0x25, 0x9d, 0xa6, 0xa9, 0xfb, 0xb8, 0x78, 0x9a,
	0xf3, 0x47, 0xa9, 0x47, 0x57, 0x62, 0x97, 0x10, 0x6a, 0xc9, 0x3c, 0xdf, 0x9, 0x6, 0x8b, 0x59,
	0x5, 0xc2, 0x31, 0x60, 0x31, 0xd8, 0x8, 0x84, 0x1, 0xe, 0x90, 0x14, 0x5f, 0x7f, 0xd4, 0xb6,
	0x26, 0xb7, 0x1d, 0x8c, 0x98, 0x58, 0xac, 0x2, 0xdf, 0x28, 0x72, 0x30, 0xd3, 0xa3, 0x6a, 0xa,
	0x19, 0x8a, 0x3a, 0x5c, 0xf3, 0x50, 0x27, 0xd8, 0x2d, 0x4d, 0xe1, 0x45, 0xc, 0x17, 0xf5, 0x56,
	0x57, 0xfb, 0x9c, 0xa, 0x24, 0xe8, 0xa4, 0x6b, 0x33, 0x1a, 0x5b, 0xb4, 0xe9, 0x50, 0xfa, 0x5c,
	0x3d, 0xfd, 0xdf, 0xf9, 0x8b, 0x6f, 0x43, 0xa9, 0x23, 0xd3, 0x53, 0x3e, 0x31, 0x6e, 0xd8, 0xfe,
	0x7c, 0x69, 0xc8, 0xb4, 0xd4, 0xdb, 0x40, 0x8c, 0x16, 0xb2, 0xa6, 0x3e, 0x21, 0x6b, 0x3, 0x18,
	0x72, 0x77, 0x1e, 0x26, 0x7, 0xb3, 0xcc, 0xfa, 0x10, 0xe5, 0x5e, 0x7b, 0x7c, 0x1c, 0x77, 0x6d
};

static const unsigned char RSA_4096_D[512] = {
	0x52, 0x56, 0xa0, 0x97, 0xda, 0xe1, 0x75, 0x2, 0x9b, 0x4, 0xe9, 0x55, 0x7b, 0x4d, 0xaa, 0x4e,
	0x7c, 0xe1, 0xae, 0x9b, 0x63, 0x9e, 0x57, 0x26, 0x88, 0x8e, 0xae, 0xf7, 0x3f, 0x66, 0x5f, 0x9f,
	0xc2, 0x9b, 0xd3, 0x13, 0x48, 0x4d, 0x6c, 0x59, 0x6a, 0xe4, 0x0, 0xa9, 0x62, 0xaa, 0xc8, 0x83,
	0x8e, 0xd5, 0x19, 0xf2, 0x52, 0xa6, 0x8d, 0x4b, 0xb6, 0xe, 0x9, 0x3, 0x7e, 0x75, 0xa, 0xd9,
	0x82, 0x6, 0x8, 0x3, 0xdc, 0xed, 0xf8, 0x48, 0x68, 0x27, 0xf1, 0x5, 0xe8, 0xab, 0xf9, 0x8f,
	0x29, 0x33, 0x24, 0xff, 0xe, 0x67, 0x9c, 0x35, 0xa1, 0x88, 0x42, 0xd4, 0x35, 0x63, 0x9, 0x3c,
	0x64, 0x80, 0x9c, 0x6d, 0x56, 0x33, 0x2f, 0x2a, 0x12, 0x3e, 0xf, 0xd9, 0xd7, 0xc5, 0x14, 0x46,
	0x64, 0x51, 0x9d, 0x85, 0x35, 0x9b, 0xb, 0x22, 0x5f, 0x91, 0xa2, 0x6e, 0xd3, 0x1c, 0x3b, 0xd9,
	0x53, 0xac, 0xe2, 0xee, 0x32, 0x39, 0xe3, 0x93, 0xe4, 0xa, 0x9a, 0xaf, 0xc, 0x12, 0x53, 0xdd,
	0x3c, 0x16, 0xd5, 0x63, 0xdf, 0xd6, 0x9f, 0xf3, 0xe3, 0x55, 0xe5, 0xf9, 0x8, 0x47, 0xfb, 0xe3,
	0xd9, 0x1f, 0x30, 0xa, 0xa7, 0xc4, 0xd9, 0xa9, 0x5c, 0x95, 0x5b, 0xd5, 0xdf, 0xf8, 0x32, 0xce,
	0x24, 0x7d, 0x6, 0xcb, 0x52, 0xe4, 0xf, 0x1c, 0xde, 0x73, 0x63, 0x79, 0x40, 0x5d, 0x75, 0x95,
	0xa3, 0x70, 0xec, 0xa9, 0xbf, 0xe0, 0xdf, 0x68, 0xbc, 0x5a, 0x39, 0x95, 0x8f, 0x9, 0xc7, 0x9c,
	0xa0, 0xc3, 0xd3, 0x2f, 0x6f, 0x5b, 0xa1, 0x67, 0xa7, 0x8e, 0x43, 0xf0, 0xae, 0x42, 0x67, 0x43,
	0xcc, 0xda, 0x67, 0xd1, 0x86, 0xa6, 0xd3, 0xfe, 0xf0, 0xf0, 0x38, 0xb8, 0xc9, 0xd7, 0x32, 0xc4,
	0xcc, 0x87, 0x9, 0x74, 0xff, 0xe7, 0x39, 0xcb, 0x69, 0x6a, 0x9f, 0xbf, 0xac, 0x6a, 0x3d, 0x85,
	0xc4, 0xc6, 0xc2, 0xa2, 0x56, 0xa4, 0x2, 0x0, 0x47, 0xa5, 0x48, 0xf2, 0xcd, 0x37, 0x90, 0x6e,
	0x5b, 0x60, 0xde, 0xd0, 0x29, 0xd4, 0xe8, 0xbe, 0x62, 0x88, 0x1a, 0xed, 0xbe, 0xba, 0x6b, 0xb5,
	0xd9, 0x84, 0x11, 0x59, 0x59, 0xb4, 0x1d, 0x20, 0x2c, 0xa8, 0x25, 0xfb, 0x6c, 0x36, 0x4d, 0x7d,
	0xf0, 0xaf, 0xa, 0x1c, 0xb6, 0xba, 0xde, 0x55, 0x71, 0x4, 0xb4, 0x3d, 0x2b, 0x20, 0xd9, 0x4e,
	0xea, 0x98, 0x6f, 0xbc, 0x45, 0x80, 0x5d, 0xb6, 0x41, 0xbf, 0xed, 0x6d, 0x1c, 0x4f, 0x62, 0xb0,
	0x93, 0x10, 0x1b, 0xa3, 0x54, 0x67, 0x52, 0xd4, 0x21, 0xaa, 0xdf, 0xc8, 0xa8, 0xaa, 0x9e, 0xf9,
	0xd1, 0x21, 0x2b, 0x6d, 0x73, 0xec, 0xb5, 0x6b, 0x3e, 0x42, 0x53, 0xfe, 0xa4, 0x29, 0x49, 0x14,
	0x6d, 0x32, 0xa7, 0x14, 0xc5, 0xa1, 0xfe, 0xc, 0x8f, 0xb3, 0x64, 0x85, 0xd, 0x4c, 0x9a, 0xbb,
	0xab, 0xdf, 0x67, 0xe9, 0x47, 0xd1, 0x4c, 0xe1, 0xd, 0xc0, 0x3c, 0xeb, 0x7d, 0xb5, 0x10, 0x6,
	0xd8, 0x8e, 0xc2, 0xe0, 0x31, 0xc7, 0xb3, 0x92, 0x28, 0xdf, 0xf3, 0x96, 0xb0, 0xb, 0x3c, 0xf5,
	0xe8, 0x5d, 0x2b, 0xaf, 0xdf, 0xe9, 0x2f, 0xf8, 0x55, 0xd2, 0xf4, 0x99, 0x2, 0x3c, 0x7e, 0x30,
	0x65, 0xaf, 0xc5, 0x68, 0x76, 0x33, 0x6a, 0xc1, 0xf2, 0x9a, 0x9f, 0xc5, 0xa3, 0x9c, 0xae, 0xe8,
	0xc0, 0x4c, 0x7, 0xd0, 0xc5, 0x6a, 0x39, 0xb6, 0xa8, 0x1b, 0x38, 0xfd, 0xaa, 0xe1, 0x10, 0x7e,
	0x2a, 0x82, 0x9c, 0x38, 0x16, 0xa5, 0x4a, 0xa3, 0x58, 0x57, 0xe1, 0xf, 0x7c, 0xba, 0x5b, 0x96,
	0x6d, 0x6a, 0x1e, 0x99, 0x9c, 0x3e, 0xfd, 0x1, 0xf6, 0x40, 0xfc, 0xd4, 0x1d, 0x89, 0x74, 0xe3,
	0xd0, 0xcb, 0x67, 0x1b, 0xb2, 0x72, 0xb2, 0xd9, 0x1, 0x35, 0xd7, 0x17, 0x12, 0x6f, 0xfa, 0x1
};

static const unsigned char RSA_4096_E[4] = {
	0x0, 0x1, 0x0, 0x1
};

typedef struct key_struc{
	hal_key_type key_type;

	/* AES Key must be 4Byte Aligned, due to hardware crypto */
	unsigned char aes_key[32] __attribute__((aligned(4)));
	uint32_t aes_key_len;

	mbedtls_rsa_context rsa_ctx;
	mbedtls_ecdh_context ecdh_ctx;
	mbedtls_ecdsa_context ecdsa_ctx;
	mbedtls_dhm_context dhm_ctx;

	unsigned char hmac_key[32];

	unsigned char *cert_data;
	uint32_t cert_len;
} key_struc;

static key_struc key_storage[KEY_STORAGE_INDEX_MAX] = { 0 };
static uint32_t init_stat = HAL_NOT_INITIALIZED;

#define MBEDTLS_CHECKBUSY() while (init_stat == HAL_BUSY) {}

/* Extern api from rtl_security_api_wrapper.c */
extern uint32_t rtl_cryptoEngine_init_wrapper(void);
extern uint32_t rtl_write_storage_wrapper(uint32_t ss_idx, hal_data *data);
extern uint32_t rtl_read_storage_wrapper(uint32_t ss_idx, hal_data *data);
extern uint32_t rtl_delete_storage_wrapper(uint32_t ss_idx);
extern uint32_t rtl_cryptoAES_ecb_wrapper(uint8_t* key, uint32_t keylen, unsigned char* message, uint32_t msglen, unsigned char* pResult, uint8_t mode);
extern uint32_t rtl_cryptoAES_cbc_wrapper(uint8_t* key, uint32_t keylen, unsigned char* message, uint32_t msglen, unsigned char* pResult, uint8_t mode);
extern uint32_t rtl_cryptoAES_ctr_wrapper(uint8_t* key, uint32_t keylen, unsigned char* message, uint32_t msglen, unsigned char* pResult, uint8_t mode);

/**
 * Helper function
 */
static int hal_rand(void *rng_state, unsigned char *output, size_t len)
{
	rtw_get_random_bytes(output, len);
	return HAL_SUCCESS;
}

/**
 * Common
 */
int ameba_hal_init(hal_init_param *params)
{
	AWRAP_ENTER;

	uint32_t ret = HAL_SUCCESS;

	if (init_stat != HAL_NOT_INITIALIZED) {
		return init_stat;
	}

	/* For mbedtls interna Debug log */
	/* mbedtls_debug_set_threshold(3); */
	for (uint32_t i = 0; i < KEY_STORAGE_INDEX_MAX; i++) {
		memset(key_storage[i].aes_key, 0, sizeof(key_storage[i].aes_key));
		key_storage[i].aes_key_len = 0;

		mbedtls_rsa_init(&(key_storage[i].rsa_ctx), MBEDTLS_RSA_PKCS_V15, 0);
		mbedtls_ecdh_init(&(key_storage[i].ecdh_ctx));
		mbedtls_ecdsa_init(&(key_storage[i].ecdsa_ctx));
		mbedtls_dhm_init(&(key_storage[i].dhm_ctx));

		memset(key_storage[i].hmac_key, 0, sizeof(key_storage[i].hmac_key));
	}

	ret = rtl_cryptoEngine_init_wrapper();					/* init crypto engine */
	if (ret == HAL_SUCCESS) {
		init_stat = HAL_SUCCESS;
	}

	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;;
	}
	return HAL_SUCCESS;
}

int ameba_hal_deinit(void)
{
	AWRAP_ENTER;

	MBEDTLS_CHECKBUSY();
	if (init_stat != HAL_SUCCESS) {
		return init_stat;
	}

	init_stat = HAL_BUSY;
	for (uint32_t i = 0; i < KEY_STORAGE_INDEX_MAX; i++) {
		memset(key_storage[i].aes_key, 0, sizeof(key_storage[i].aes_key));
		key_storage[i].aes_key_len = 0;

		mbedtls_rsa_free(&(key_storage[i].rsa_ctx));
		mbedtls_ecdh_free(&(key_storage[i].ecdh_ctx));
		mbedtls_ecdsa_free(&(key_storage[i].ecdsa_ctx));
		mbedtls_dhm_free(&(key_storage[i].dhm_ctx));

		memset(key_storage[i].hmac_key, 0, sizeof(key_storage[i].hmac_key));
	}
	init_stat = HAL_NOT_INITIALIZED;

	return HAL_SUCCESS;
}

int ameba_hal_free_data(hal_data *data)
{
	AWRAP_ENTER;
	if (data) {
		if (data->data) {
			free(data->data);
		}
		if (data->priv) {
			free(data->priv);
		}
	}
	return HAL_SUCCESS;
}

int ameba_hal_get_status(void)
{
	AWRAP_ENTER;
	return init_stat;
}

/**
 * Key Manager
 */
int ameba_hal_set_key(hal_key_type mode, uint32_t key_idx, hal_data *key, hal_data *prikey)
{
	AWRAP_ENTER;

	uint32_t ret = HAL_SUCCESS;

	MBEDTLS_CHECKBUSY();

	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (prikey != NULL) {	/* If private key is pass in */
		return HAL_NOT_SUPPORTED;
	}
	if (key_idx > KEY_STORAGE_INDEX_MAX) {	/* Index Out of Range */
		return HAL_INVALID_SLOT_RANGE;
	}

	init_stat = HAL_BUSY;
	switch (mode) {
	case HAL_KEY_AES_128:
	case HAL_KEY_AES_192:
	case HAL_KEY_AES_256:
		/* Key size is fixed, 128 = 16, 192 = 24, 256 = 32, if key size large then 32bytes, is invalid input */
		if (sizeof(key_storage[key_idx].aes_key) < key->data_len) {	/* Key size larger than storage */
			ret = HAL_INVALID_ARGS;
			goto exit;
		}
		memcpy(key_storage[key_idx].aes_key, key->data, key->data_len);
		key_storage[key_idx].aes_key_len = key->data_len;
		break;
	case HAL_KEY_RSA_1024:
	case HAL_KEY_RSA_2048:
	case HAL_KEY_RSA_3072:
	case HAL_KEY_RSA_4096:
		/* Not sure what to do, hal test case did not mention */
		break;
	case HAL_KEY_ECC_BRAINPOOL_P256R1:
	case HAL_KEY_ECC_BRAINPOOL_P384R1:
	case HAL_KEY_ECC_BRAINPOOL_P512R1:
	case HAL_KEY_ECC_SEC_P192R1:
	case HAL_KEY_ECC_SEC_P224R1:
	case HAL_KEY_ECC_SEC_P256R1:
	case HAL_KEY_ECC_SEC_P384R1:
	case HAL_KEY_ECC_SEC_P512R1:
		/* For ECC there two public key X and Y, key->data and key->priv? information base on spec */
		/* Read Public key from char format to MPI format */
		if ((mbedtls_mpi_read_binary(&(key_storage[key_idx].ecdh_ctx.Q.X), key->data, key->data_len) != HAL_SUCCESS)
		|| (mbedtls_mpi_read_binary(&(key_storage[key_idx].ecdh_ctx.Q.Y), key->priv, key->priv_len) != HAL_SUCCESS)) {
			ret = HAL_INVALID_ARGS;	/* if not success */
		}
		break;
	case HAL_KEY_HMAC_MD5:
	case HAL_KEY_HMAC_SHA1:
	case HAL_KEY_HMAC_SHA224:
	case HAL_KEY_HMAC_SHA256:
	case HAL_KEY_HMAC_SHA384:
	case HAL_KEY_HMAC_SHA512:
		/* Key is no use, due to not support HMAC, do not let key size more then storage size */
		if (sizeof(key_storage[key_idx].hmac_key) < key->data_len) {	/* Key size larger than storage */
			/* Prevent overflow */
			memcpy(key_storage[key_idx].hmac_key, key->data, sizeof(key_storage[key_idx].hmac_key));
		} else {
			memcpy(key_storage[key_idx].hmac_key, key->data, key->data_len);
		}
		break;
	case HAL_KEY_DH_1024:
	case HAL_KEY_DH_2048:
	case HAL_KEY_DH_4096:
		break;
	default:
		return HAL_NOT_SUPPORTED;
	}
	key_storage[key_idx].key_type = mode;

exit:
	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;;
	}
	return HAL_SUCCESS;
}

int ameba_hal_get_key(hal_key_type mode, uint32_t key_idx, hal_data *key)
{
	AWRAP_ENTER;

	uint32_t ret = HAL_SUCCESS;
	uint32_t puk_x_len, puk_y_len;
	unsigned char *puk_x;
	unsigned char *puk_y;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (key_idx > KEY_STORAGE_INDEX_MAX) {	/* Index Out of Range */
		return HAL_INVALID_SLOT_RANGE;
	}

	/* Base on SSS function it only accept ((mode <= HAL_KEY_ECC_SEC_P512R1) && (mode >= HAL_KEY_ECC_BRAINPOOL_P256R1)) */
	if ((mode <= HAL_KEY_ECC_SEC_P512R1) && (mode >= HAL_KEY_ECC_BRAINPOOL_P256R1)) {
		init_stat = HAL_BUSY;

		puk_x_len = mbedtls_mpi_size(&(key_storage[key_idx].ecdh_ctx.Q.X));	/* Get length */
		puk_y_len = mbedtls_mpi_size(&(key_storage[key_idx].ecdh_ctx.Q.Y));	/* Get length */
		puk_x = (unsigned char *)malloc(puk_x_len);	/* Allocate memory */
		puk_y = (unsigned char *)malloc(puk_y_len);	/* Allocate memory */

		if ((puk_x == NULL) || (puk_y == NULL)) {
			ret = HAL_NOT_ENOUGH_MEMORY;	/* Memory not enough */
		} else {
			/* For ECC there two public key X and Y, key->data and key->priv? information base on spec */
			/* Read Public key from MPI format to char format */
			if ((mbedtls_mpi_write_binary(&(key_storage[key_idx].ecdh_ctx.Q.X), puk_x, puk_x_len) != HAL_SUCCESS)
			|| (mbedtls_mpi_write_binary(&(key_storage[key_idx].ecdh_ctx.Q.Y), puk_y, puk_y_len) != HAL_SUCCESS)) {
				ret = HAL_FAIL;	/* if not success */
			} else {	/* Success Case, Copy data */
				HAL_COPY_DATA(key, puk_x, puk_x_len);	/* data: publickey_x, priv: publickey_y */
				HAL_COPY_PRIV_DATA(key, puk_y, puk_y_len);
			}
		}
		if (puk_x != NULL) {
			free(puk_x);	/* free memory */
		}
		if (puk_y != NULL) {
			free(puk_y);	/* free memory */
		}
	} else {
		return HAL_NOT_SUPPORTED;
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_remove_key(hal_key_type mode, uint32_t key_idx)
{
	AWRAP_ENTER;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (key_idx > KEY_STORAGE_INDEX_MAX) {	/* Index Out of Range */
		return HAL_INVALID_SLOT_RANGE;
	}
	if (mode != key_storage[key_idx].key_type) {
		return HAL_BAD_KEY;	/* Key is empty */
	}
	init_stat = HAL_BUSY;

	/* Init all key info for key index */
	memset(key_storage[key_idx].aes_key, 0, sizeof(key_storage[key_idx].aes_key));
	key_storage[key_idx].aes_key_len = 0;

	mbedtls_rsa_init(&(key_storage[key_idx].rsa_ctx), MBEDTLS_RSA_PKCS_V15, 0);
	mbedtls_ecdh_init(&(key_storage[key_idx].ecdh_ctx));
	mbedtls_ecdsa_init(&(key_storage[key_idx].ecdsa_ctx));
	mbedtls_dhm_init(&(key_storage[key_idx].dhm_ctx));

	memset(key_storage[key_idx].hmac_key, 0, sizeof(key_storage[key_idx].hmac_key));
	key_storage[key_idx].key_type = HAL_KEY_UNKNOWN;	/* Remove key type for key index */

	init_stat = HAL_SUCCESS;
	return HAL_SUCCESS;
}

int ameba_hal_generate_key(hal_key_type mode, uint32_t key_idx)
{
	AWRAP_ENTER;

	uint32_t ret = HAL_SUCCESS;
	mbedtls_ecp_group_id ecp_curve_id;

	MBEDTLS_CHECKBUSY();

	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	init_stat = HAL_BUSY;
	switch (mode) {
	case HAL_KEY_AES_128:
		/* Generate Random Key */
		rtw_get_random_bytes(key_storage[key_idx].aes_key, AES_128_KEY_SIZE);
		key_storage[key_idx].aes_key_len = AES_128_KEY_SIZE;
		break;
	case HAL_KEY_AES_192:
		/* Generate Random Key */
		rtw_get_random_bytes(key_storage[key_idx].aes_key, AES_192_KEY_SIZE);
		key_storage[key_idx].aes_key_len = AES_192_KEY_SIZE;
		break;
	case HAL_KEY_AES_256:
		/* Generate Random Key */
		rtw_get_random_bytes(key_storage[key_idx].aes_key, AES_256_KEY_SIZE);
		key_storage[key_idx].aes_key_len = AES_256_KEY_SIZE;
		break;
	case HAL_KEY_RSA_1024:
		/* ret = mbedtls_rsa_gen_key(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, 1024, 65537); */

		ret = mbedtls_rsa_import_raw(&(key_storage[key_idx].rsa_ctx), RSA_1024_N, sizeof(RSA_1024_N), RSA_1024_P, sizeof(RSA_1024_P), RSA_1024_Q, sizeof(RSA_1024_Q), RSA_1024_D, sizeof(RSA_1024_D), RSA_1024_E, sizeof(RSA_1024_E));
		if (ret == HAL_SUCCESS) {
			ret = mbedtls_rsa_complete(&(key_storage[key_idx].rsa_ctx));
		}
		break;
	case HAL_KEY_RSA_2048:
		/* ret = mbedtls_rsa_gen_key(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, 2048, 65537); */

		ret = mbedtls_rsa_import_raw(&(key_storage[key_idx].rsa_ctx), RSA_2048_N, sizeof(RSA_2048_N), RSA_2048_P, sizeof(RSA_2048_P), RSA_2048_Q, sizeof(RSA_2048_Q), RSA_2048_D, sizeof(RSA_2048_D), RSA_2048_E, sizeof(RSA_2048_E));
		if (ret == HAL_SUCCESS) {
			ret = mbedtls_rsa_complete(&(key_storage[key_idx].rsa_ctx));
		}
		break;
	case HAL_KEY_RSA_3072:
		/* ret = mbedtls_rsa_gen_key(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, 3072, 65537); */

		ret = mbedtls_rsa_import_raw(&(key_storage[key_idx].rsa_ctx), RSA_3072_N, sizeof(RSA_3072_N), RSA_3072_P, sizeof(RSA_3072_P), RSA_3072_Q, sizeof(RSA_3072_Q), RSA_3072_D, sizeof(RSA_3072_D), RSA_3072_E, sizeof(RSA_3072_E));
		if (ret == HAL_SUCCESS) {
			ret = mbedtls_rsa_complete(&(key_storage[key_idx].rsa_ctx));
		}
		break;
	case HAL_KEY_RSA_4096:
		/* ret = mbedtls_rsa_gen_key(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, 4096, 65537); */

		ret = mbedtls_rsa_import_raw(&(key_storage[key_idx].rsa_ctx), RSA_4096_N, sizeof(RSA_4096_N), RSA_4096_P, sizeof(RSA_4096_P), RSA_4096_Q, sizeof(RSA_4096_Q), RSA_4096_D, sizeof(RSA_4096_D), RSA_4096_E, sizeof(RSA_4096_E));
		if (ret == HAL_SUCCESS) {
			ret = mbedtls_rsa_complete(&(key_storage[key_idx].rsa_ctx));
		}
		break;
	case HAL_KEY_ECC_BRAINPOOL_P256R1:
		ecp_curve_id = MBEDTLS_ECP_DP_BP256R1;
		break;
	case HAL_KEY_ECC_BRAINPOOL_P384R1:
		ecp_curve_id = MBEDTLS_ECP_DP_BP384R1;
		break;
	case HAL_KEY_ECC_BRAINPOOL_P512R1:
		ecp_curve_id = MBEDTLS_ECP_DP_BP512R1;
		break;
	case HAL_KEY_ECC_SEC_P192R1:
		ecp_curve_id = MBEDTLS_ECP_DP_SECP192R1;
		break;
	case HAL_KEY_ECC_SEC_P224R1:
		ecp_curve_id = MBEDTLS_ECP_DP_SECP224R1;
		break;
	case HAL_KEY_ECC_SEC_P256R1:
		ecp_curve_id = MBEDTLS_ECP_DP_SECP256R1;
		break;
	case HAL_KEY_ECC_SEC_P384R1:
		ecp_curve_id = MBEDTLS_ECP_DP_SECP384R1;
		break;
	case HAL_KEY_ECC_SEC_P512R1:
		ecp_curve_id = MBEDTLS_ECP_DP_SECP521R1;
		break;
	case HAL_KEY_HMAC_MD5:
	case HAL_KEY_HMAC_SHA1:
	case HAL_KEY_HMAC_SHA224:
	case HAL_KEY_HMAC_SHA256:
	case HAL_KEY_HMAC_SHA384:
	case HAL_KEY_HMAC_SHA512:
		break;
	default:
		init_stat = HAL_SUCCESS;
		return HAL_NOT_SUPPORTED;
	}

	if ((HAL_KEY_ECC_BRAINPOOL_P256R1 <= mode)
	&& (HAL_KEY_ECC_SEC_P512R1 >= mode)) {
		/* ECDH and ECDASA share same curve ID, but use diffrent struct to store key info */
		/* ECDSA operation */
		if ((mbedtls_ecdsa_genkey(&(key_storage[key_idx].ecdsa_ctx), ecp_curve_id, hal_rand, NULL) != HAL_SUCCESS)
		/* ECDH operation */
		|| (mbedtls_ecp_group_load(&(key_storage[key_idx].ecdh_ctx.grp), ecp_curve_id) != HAL_SUCCESS)
		|| (mbedtls_ecdh_gen_public(&(key_storage[key_idx].ecdh_ctx.grp), &(key_storage[key_idx].ecdh_ctx.d), &(key_storage[key_idx].ecdh_ctx.Q), hal_rand, NULL) != HAL_SUCCESS)) {
			ret = HAL_FAIL;
		}
	}

	if (ret == HAL_SUCCESS) {
		key_storage[key_idx].key_type = mode;	/* Set storage key mode */
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

/**
 * Authenticate
 */
int ameba_hal_generate_random(uint32_t len, hal_data *random)
{
	AWRAP_ENTER;

	uint32_t ret;
	unsigned char inbuf[HAL_MAX_RANDOM_SIZE];

	if (len > HAL_MAX_RANDOM_SIZE) {
		return HAL_INVALID_ARGS;
	}

	ret = rtw_get_random_bytes(inbuf, len);
	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(random, inbuf, len);
	}

	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_get_hash(hal_hash_type mode, hal_data *input, hal_data *hash)
{
	AWRAP_ENTER;
	
	uint32_t len;
	unsigned char output[64];

	switch (mode) {
	case HAL_HASH_MD5:
		mbedtls_md5(input->data, input->data_len, output);
		break;
	case HAL_HASH_SHA1:
		mbedtls_sha1(input->data, input->data_len, output);
		break;
	case HAL_HASH_SHA224:
		mbedtls_sha256(input->data, input->data_len, output, MBEDTLS_HASH_SHA224);
		break;
	case HAL_HASH_SHA256:
		mbedtls_sha256(input->data, input->data_len, output, MBEDTLS_HASH_SHA256);
		break;
	case HAL_HASH_SHA384:
		mbedtls_sha512(input->data, input->data_len, output, MBEDTLS_HASH_SHA384);
		break;
	case HAL_HASH_SHA512:
		mbedtls_sha512(input->data, input->data_len, output, MBEDTLS_HASH_SHA512);
		break;
	default:
		return HAL_NOT_SUPPORTED;
	}

	len = strlen((char*) output);
	if (len != 0) {
		HAL_COPY_DATA(hash, output, len);
		return HAL_SUCCESS;
	} else {
		sedbg("MbedTLS failed (%zu)\n", HAL_FAIL);
		return HAL_FAIL;
	}
}

int ameba_hal_get_hmac(hal_hmac_type mode, hal_data *input, uint32_t key_idx, hal_data *hmac)
{
	AWRAP_ENTER;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	init_stat = HAL_BUSY;
	init_stat = HAL_SUCCESS;
	return HAL_NOT_SUPPORTED;
}

int ameba_hal_rsa_sign_md(hal_rsa_mode mode, hal_data *hash, uint32_t key_idx, hal_data *sign)
{
	AWRAP_ENTER;

	uint32_t ret;
	mbedtls_md_type_t sha_mode;
	unsigned char sig_out[1024];

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_RSA_1024 > key_storage[key_idx].key_type)
	|| (HAL_KEY_RSA_4096 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}

	switch (mode.hash_t) {
	case HAL_HASH_MD5:
		sha_mode = MBEDTLS_MD_MD5;
		break;
	case HAL_HASH_SHA1:
		sha_mode = MBEDTLS_MD_SHA1;
		break;
	case HAL_HASH_SHA224:
		sha_mode = MBEDTLS_MD_SHA224;
		break;
	case HAL_HASH_SHA256:
		sha_mode = MBEDTLS_MD_SHA256;
		break;
	case HAL_HASH_SHA384:
		sha_mode = MBEDTLS_MD_SHA384;
		break;
	case HAL_HASH_SHA512:
		sha_mode = MBEDTLS_MD_SHA512;
		break;
	default:
		return HAL_NOT_SUPPORTED;
	}
	init_stat = HAL_BUSY;

	if (mode.rsa_a == HAL_RSASSA_PKCS1_V1_5) {
		mbedtls_rsa_set_padding(&(key_storage[key_idx].rsa_ctx), MBEDTLS_RSA_PKCS_V15, 0);
	} else if (mode.rsa_a == HAL_RSASSA_PKCS1_PSS_MGF1) {
		mbedtls_rsa_set_padding(&(key_storage[key_idx].rsa_ctx), MBEDTLS_RSA_PKCS_V21, sha_mode);
	} else {
		ret = HAL_NOT_SUPPORTED;
		goto exit;
	}
	ret = mbedtls_rsa_pkcs1_sign(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, MBEDTLS_RSA_PRIVATE, sha_mode, hash->data_len, hash->data, sig_out);

	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(sign, sig_out, key_storage[key_idx].rsa_ctx.len);
	}

exit:
	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_rsa_verify_md(hal_rsa_mode mode, hal_data *hash, hal_data *sign, uint32_t key_idx)
{
	AWRAP_ENTER;

	uint32_t ret;
	mbedtls_md_type_t sha_mode;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_RSA_1024 > key_storage[key_idx].key_type)
	|| (HAL_KEY_RSA_4096 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}

	switch (mode.hash_t) {
	case HAL_HASH_MD5:
		sha_mode = MBEDTLS_MD_MD5;
		break;
	case HAL_HASH_SHA1:
		sha_mode = MBEDTLS_MD_SHA1;
		break;
	case HAL_HASH_SHA224:
		sha_mode = MBEDTLS_MD_SHA224;
		break;
	case HAL_HASH_SHA256:
		sha_mode = MBEDTLS_MD_SHA256;
		break;
	case HAL_HASH_SHA384:
		sha_mode = MBEDTLS_MD_SHA384;
		break;
	case HAL_HASH_SHA512:
		sha_mode = MBEDTLS_MD_SHA512;
		break;
	default:
		return HAL_NOT_SUPPORTED;
	}
	init_stat = HAL_BUSY;

	if (mode.rsa_a == HAL_RSASSA_PKCS1_V1_5) {
		mbedtls_rsa_set_padding(&(key_storage[key_idx].rsa_ctx), MBEDTLS_RSA_PKCS_V15, 0);
	} else if (mode.rsa_a == HAL_RSASSA_PKCS1_PSS_MGF1) {
		mbedtls_rsa_set_padding(&(key_storage[key_idx].rsa_ctx), MBEDTLS_RSA_PKCS_V21, sha_mode);
	} else {
		ret = HAL_NOT_SUPPORTED;
		goto exit;
	}
	ret = mbedtls_rsa_pkcs1_verify(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, MBEDTLS_RSA_PUBLIC, sha_mode, hash->data_len, hash->data, (unsigned char *)sign->data);

exit:
	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_ecdsa_sign_md(hal_ecdsa_mode mode, hal_data *hash, uint32_t key_idx, hal_data *sign)
{
	AWRAP_ENTER;

	uint32_t ret;
	uint32_t sig_len;
	unsigned char sig[MBEDTLS_ECDSA_MAX_LEN];
	mbedtls_md_type_t hash_type;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_ECC_BRAINPOOL_P256R1 > key_storage[key_idx].key_type)
	|| (HAL_KEY_ECC_SEC_P512R1 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}
	switch (mode.hash_t) {
	case HAL_HASH_MD5:
		hash_type = MBEDTLS_MD_MD5;
		break;
	case HAL_HASH_SHA256:
		hash_type = MBEDTLS_MD_SHA256;
		break;
	case HAL_HASH_SHA384:
		hash_type = MBEDTLS_MD_SHA384;
		break;
	case HAL_HASH_SHA512:
		hash_type = MBEDTLS_MD_SHA512;
		break;
	default:
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;

	ret = mbedtls_ecdsa_write_signature(&(key_storage[key_idx].ecdsa_ctx), hash_type, hash->data, hash->data_len, sig, &sig_len, hal_rand, NULL);
	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(sign, sig, sig_len);
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_ecdsa_verify_md(hal_ecdsa_mode mode, hal_data *hash, hal_data *sign, uint32_t key_idx)
{
	AWRAP_ENTER;

	uint32_t ret;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_ECC_BRAINPOOL_P256R1 > key_storage[key_idx].key_type)
	|| (HAL_KEY_ECC_SEC_P512R1 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;
	
	ret = mbedtls_ecdsa_read_signature(&(key_storage[key_idx].ecdsa_ctx), hash->data, hash->data_len, sign->data, sign->data_len);

	init_stat = HAL_SUCCESS;
	return ret;
}

int ameba_hal_dh_generate_param(uint32_t dh_idx, hal_dh_data *dh_param)
{
	AWRAP_ENTER;

	uint32_t ret;
	size_t p_size, output_len = 0;
	unsigned char *output;
	mbedtls_mpi mpi_P;
	mbedtls_mpi mpi_G;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (!dh_param->pubkey->data) {
		return HAL_INVALID_ARGS;
	}
	switch (dh_param->mode) {
	case HAL_DH_1024:
	case HAL_DH_2048:
	case HAL_DH_4096:
		break;
	default:
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;

	mbedtls_mpi_init(&mpi_P);
	mbedtls_mpi_init(&mpi_G);

	/* Read G and P from G inout, Then G and P set in the context */
	if ((mbedtls_mpi_read_binary(&mpi_P, dh_param->P->data, dh_param->P->data_len) != HAL_SUCCESS)
	|| (mbedtls_mpi_read_binary(&mpi_G, dh_param->G->data, dh_param->G->data_len) != HAL_SUCCESS)
	|| (mbedtls_dhm_set_group(&(key_storage[dh_idx].dhm_ctx), &mpi_P, &mpi_G) != HAL_SUCCESS)) {
		ret = HAL_FAIL;
		goto exit;
	}

	output = (unsigned char *)malloc(HAL_MAX_BUF_SIZE);
	if (output == NULL) {
		ret = HAL_NOT_ENOUGH_MEMORY;
		goto exit;
	}
	/* Sets up and writes the ServerKeyExchange parameters */
	p_size = mbedtls_mpi_size(&key_storage[dh_idx].dhm_ctx.P);
	ret = mbedtls_dhm_make_params(&(key_storage[dh_idx].dhm_ctx), (int)p_size, output, &output_len, hal_rand, NULL);
	free(output);	/* Output is not needed to exports, Output is Param */

	if (ret == HAL_SUCCESS) {
		output_len = key_storage[dh_idx].dhm_ctx.len;
		output = (unsigned char *)malloc(output_len);
		if (output == NULL) {
			ret = HAL_NOT_ENOUGH_MEMORY;
			goto exit;
		}
		/* Creates its own private value X and exports G^X, GX = (G^X mod P) */
		ret = mbedtls_dhm_make_public(&(key_storage[dh_idx].dhm_ctx), key_storage[dh_idx].dhm_ctx.len, output, output_len, hal_rand, NULL);

		if (ret == HAL_SUCCESS) {
			/* This API generates GX (G^X mod P) wichi is a pubkey in dh_param with the given input G and P. */
			memcpy(dh_param->pubkey->data, output, output_len);
			dh_param->pubkey->data_len = output_len;
		}	
	}

exit:
	mbedtls_mpi_free(&mpi_P);
	mbedtls_mpi_free(&mpi_G);
	free(output);

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_dh_compute_shared_secret(hal_dh_data *dh_param, uint32_t dh_idx, hal_data *shared_secret)
{
	AWRAP_ENTER;

	uint32_t ret;
	size_t buf_size, output_len = 0;
	unsigned char *output;
	mbedtls_mpi mpi_P;
	mbedtls_mpi mpi_G;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	switch (dh_param->mode) {
	case HAL_DH_1024:
	case HAL_DH_2048:
	case HAL_DH_4096:
		break;
	default:
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;

	mbedtls_mpi_init(&mpi_P);
	mbedtls_mpi_init(&mpi_G);

	/* Read G and P from G inout, Then G and P set in the context */
	/* Read public key from input */
	if ((mbedtls_mpi_read_binary(&mpi_P, dh_param->P->data, dh_param->P->data_len) != HAL_SUCCESS)
	|| (mbedtls_mpi_read_binary(&mpi_G, dh_param->G->data, dh_param->G->data_len) != HAL_SUCCESS)
	|| (mbedtls_dhm_set_group(&(key_storage[dh_idx].dhm_ctx), &mpi_P, &mpi_G) != HAL_SUCCESS)
	|| (mbedtls_dhm_read_public(&(key_storage[dh_idx].dhm_ctx), dh_param->pubkey->data, dh_param->pubkey->data_len) != HAL_SUCCESS)) {
		ret = HAL_FAIL;
		goto exit;
	}

	buf_size = key_storage[dh_idx].dhm_ctx.len;
	output = (unsigned char *)malloc(buf_size);
	ret = mbedtls_dhm_calc_secret(&(key_storage[dh_idx].dhm_ctx), output, buf_size, &output_len, hal_rand, NULL);

	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(shared_secret, output, output_len);
	}

exit:
	mbedtls_mpi_free(&mpi_P);
	mbedtls_mpi_free(&mpi_G);
	free(output);

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_ecdh_compute_shared_secret(hal_ecdh_data *ecdh_param, uint32_t key_idx, hal_data *shared_secret)
{
	AWRAP_ENTER;

	uint32_t ret;
	uint32_t Qp_z_len, output_len = 0;
	unsigned char *Qp_z;
	unsigned char output[HAL_MAX_SHARED_SECRET_LEN];

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_ECC_BRAINPOOL_P256R1 > key_storage[key_idx].key_type)
	&& (HAL_KEY_ECC_SEC_P512R1 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;

	/* Read peer public key X and Y */
	if ((mbedtls_mpi_read_binary(&(key_storage[key_idx].ecdh_ctx.Qp.X), ecdh_param->pubkey_x->data, ecdh_param->pubkey_x->data_len) != HAL_SUCCESS)
	|| (mbedtls_mpi_read_binary(&(key_storage[key_idx].ecdh_ctx.Qp.Y), ecdh_param->pubkey_y->data, ecdh_param->pubkey_y->data_len) != HAL_SUCCESS)) {
		ret = HAL_FAIL;
		goto exit;
	}

	/* Set Z key */
	Qp_z_len = mbedtls_mpi_size(&(key_storage[key_idx].ecdh_ctx.Q.Z));	/* Get Key size */
	Qp_z = (unsigned char *)malloc(Qp_z_len);	/* Allocate memory */
	if (Qp_z == NULL) {
		ret = HAL_NOT_ENOUGH_MEMORY;	/* Memory not enough */
		goto exit;
	}
	memset(Qp_z, 0, Qp_z_len);	/* Set All zero */
	Qp_z[Qp_z_len - 1] = 1;	/* Set last byte 1 */
	if (mbedtls_mpi_read_binary(&(key_storage[key_idx].ecdh_ctx.Qp.Z), Qp_z, Qp_z_len) != HAL_SUCCESS) {
		ret = HAL_FAIL;
		goto exit;
	}

	/* Secret compute */
	ret = mbedtls_ecdh_compute_shared(&(key_storage[key_idx].ecdh_ctx.grp), &(key_storage[key_idx].ecdh_ctx.z), &(key_storage[key_idx].ecdh_ctx.Qp), &(key_storage[key_idx].ecdh_ctx.d), hal_rand, NULL);
	/* Shared Secret compute success */
	if (ret == HAL_SUCCESS) {
		/* Write Shared Secret from MPI formtat to char format */
		ret = mbedtls_mpi_write_binary(&(key_storage[key_idx].ecdh_ctx.z), output, HAL_MAX_SHARED_SECRET_LEN);
		output_len = mbedtls_mpi_size(&(key_storage[key_idx].ecdh_ctx.z));	/* Get size */

		if (ret == HAL_SUCCESS) {
			/* Copy Shared Secret to output buffer */
			HAL_COPY_DATA(shared_secret, output, output_len);
		}
	}

exit:
	free(Qp_z);

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_set_certificate(uint32_t cert_idx, hal_data *cert_in)
{
	AWRAP_ENTER;

	uint32_t ret = HAL_SUCCESS;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (cert_idx > KEY_STORAGE_INDEX_MAX) {	/* Index Out of Range */
		return HAL_INVALID_SLOT_RANGE;
	}
	init_stat = HAL_BUSY;

	/* If cert exist */
	if (key_storage[cert_idx].cert_data != NULL) {
		free(key_storage[cert_idx].cert_data);	/* Free existing Cert memory */
	}
	key_storage[cert_idx].cert_data = malloc(cert_in->data_len);	/* malloc for new cert */

	/* Copy cert data and length into local storage */
	memcpy(key_storage[cert_idx].cert_data, cert_in->data, cert_in->data_len);
	key_storage[cert_idx].cert_len = cert_in->data_len;

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_get_certificate(uint32_t cert_idx, hal_data *cert_out)
{
	AWRAP_ENTER;

	uint32_t ret = HAL_SUCCESS;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (cert_idx > KEY_STORAGE_INDEX_MAX) {	/* Index Out of Range */
		return HAL_INVALID_SLOT_RANGE;
	}
	if (key_storage[cert_idx].cert_data == NULL) {
		return HAL_EMPTY_SLOT;
	}
	init_stat = HAL_BUSY;

	HAL_COPY_DATA(cert_out, key_storage[cert_idx].cert_data, key_storage[cert_idx].cert_len);

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_remove_certificate(uint32_t cert_idx)
{
	AWRAP_ENTER;

	return HAL_NOT_SUPPORTED;
}

int ameba_hal_get_factory_key(uint32_t key_idx, hal_data *key)
{
	AWRAP_ENTER;

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if (key_idx == FACTORYKEY_RTL_DEVICE) {
		HAL_COPY_DATA(key, EC_Private_Key, sizeof(EC_Private_Key));
	} else {
		return HAL_NOT_SUPPORTED;
	}
	return HAL_SUCCESS;
}

int ameba_hal_get_factory_cert(uint32_t cert_idx, hal_data *cert)
{
	AWRAP_ENTER;

	MBEDTLS_CHECKBUSY();

	if (cert_idx == FACTORYKEY_RTL_CERT) {
		HAL_COPY_DATA(cert, HA_IOT_Device_Cert, sizeof(HA_IOT_Device_Cert));
	} else {
		return HAL_NOT_SUPPORTED;
	}
	return HAL_SUCCESS;
}

int ameba_hal_get_factory_data(uint32_t data_idx, hal_data *data)
{
	AWRAP_ENTER;

	return HAL_NOT_SUPPORTED;
}

/**
 * Crypto
 */
int ameba_hal_aes_encrypt(hal_data *dec_data, hal_aes_param *aes_param, uint32_t key_idx, hal_data *enc_data)
{
	AWRAP_ENTER;

	uint32_t ret;
	unsigned char aes_output[HAL_MAX_BUF_SIZE];

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_AES_128 != key_storage[key_idx].key_type)
	&& (HAL_KEY_AES_192 != key_storage[key_idx].key_type)
	&& (HAL_KEY_AES_256 != key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;	/* Mode not match */
	}

	init_stat = HAL_BUSY;
	switch (aes_param->mode) {
	case HAL_AES_ECB_NOPAD:
	case HAL_AES_ECB_ISO9797_M1:
	case HAL_AES_ECB_ISO9797_M2:
	case HAL_AES_ECB_PKCS5:
	case HAL_AES_ECB_PKCS7:
		ret = rtl_cryptoAES_ecb_wrapper(key_storage[key_idx].aes_key, key_storage[key_idx].aes_key_len, dec_data->data, dec_data->data_len, aes_output, MBEDTLS_ENCRYPT);
		break;
	case HAL_AES_CBC_NOPAD:
	case HAL_AES_CBC_ISO9797_M1:
	case HAL_AES_CBC_ISO9797_M2:
	case HAL_AES_CBC_PKCS5:
	case HAL_AES_CBC_PKCS7:
		ret = rtl_cryptoAES_cbc_wrapper(key_storage[key_idx].aes_key, key_storage[key_idx].aes_key_len, dec_data->data, dec_data->data_len, aes_output, MBEDTLS_ENCRYPT);
		break;
	case HAL_AES_CTR:
		ret = rtl_cryptoAES_cbc_wrapper(key_storage[key_idx].aes_key, key_storage[key_idx].aes_key_len, dec_data->data, dec_data->data_len, aes_output, MBEDTLS_ENCRYPT);
		break;
	default:
		return HAL_NOT_SUPPORTED;
	}

	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(enc_data, aes_output, dec_data->data_len);
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_aes_decrypt(hal_data *enc_data, hal_aes_param *aes_param, uint32_t key_idx, hal_data *dec_data)
{
	AWRAP_ENTER;

	uint32_t ret;
	unsigned char aes_output[HAL_MAX_BUF_SIZE];

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_AES_128 != key_storage[key_idx].key_type)
	&& (HAL_KEY_AES_192 != key_storage[key_idx].key_type)
	&& (HAL_KEY_AES_256 != key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}

	init_stat = HAL_BUSY;
	switch (aes_param->mode) {
	case HAL_AES_ECB_NOPAD:
	case HAL_AES_ECB_ISO9797_M1:
	case HAL_AES_ECB_ISO9797_M2:
	case HAL_AES_ECB_PKCS5:
	case HAL_AES_ECB_PKCS7:
		ret = rtl_cryptoAES_ecb_wrapper(key_storage[key_idx].aes_key, key_storage[key_idx].aes_key_len, enc_data->data, enc_data->data_len, aes_output, MBEDTLS_DECRYPT);
		break;
	case HAL_AES_CBC_NOPAD:
	case HAL_AES_CBC_ISO9797_M1:
	case HAL_AES_CBC_ISO9797_M2:
	case HAL_AES_CBC_PKCS5:
	case HAL_AES_CBC_PKCS7:
		ret = rtl_cryptoAES_cbc_wrapper(key_storage[key_idx].aes_key, key_storage[key_idx].aes_key_len, enc_data->data, enc_data->data_len, aes_output, MBEDTLS_DECRYPT);
		break;
	case HAL_AES_CTR:
		ret = rtl_cryptoAES_cbc_wrapper(key_storage[key_idx].aes_key, key_storage[key_idx].aes_key_len, enc_data->data, enc_data->data_len, aes_output, MBEDTLS_DECRYPT);
		break;
	default:
		return HAL_NOT_SUPPORTED;
	}

	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(dec_data, aes_output, enc_data->data_len);
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_rsa_encrypt(hal_data *dec_data, hal_rsa_mode *rsa_mode, uint32_t key_idx, hal_data *enc_data)
{
	AWRAP_ENTER;

	uint32_t ret;
	size_t output_len;
	unsigned char output[HAL_MAX_BUF_SIZE] = {0};

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_RSA_1024 > key_storage[key_idx].key_type)
	&& (HAL_KEY_RSA_4096 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;

	ret = mbedtls_rsa_pkcs1_encrypt(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, MBEDTLS_RSA_PUBLIC, dec_data->data_len, dec_data->data, output);

	/* Output length always size of \p ctx->N, For example, 128 Bytes if RSA-1024 is used. */
	output_len = mbedtls_mpi_size(&(key_storage[key_idx].rsa_ctx.N));

	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(enc_data, output, output_len);
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_rsa_decrypt(hal_data *enc_data, hal_rsa_mode *rsa_mode, uint32_t key_idx, hal_data *dec_data)
{
	AWRAP_ENTER;

	uint32_t ret;
	size_t output_len;
	unsigned char input[HAL_MAX_BUF_SIZE] = {0};
	unsigned char output[HAL_MAX_BUF_SIZE] = {0};

	MBEDTLS_CHECKBUSY();
	if (init_stat == HAL_NOT_INITIALIZED) {
		return HAL_NOT_INITIALIZED;
	}
	if ((HAL_KEY_RSA_1024 > key_storage[key_idx].key_type)
	&& (HAL_KEY_RSA_4096 < key_storage[key_idx].key_type)) {
		return HAL_INVALID_ARGS;
	}
	init_stat = HAL_BUSY;

	memcpy(input, enc_data->data, enc_data->data_len);

	ret = mbedtls_rsa_pkcs1_decrypt(&(key_storage[key_idx].rsa_ctx), hal_rand, NULL, MBEDTLS_RSA_PRIVATE, &output_len, input, output, HAL_MAX_BUF_SIZE);

	if (ret == HAL_SUCCESS) {
		HAL_COPY_DATA(dec_data, output, output_len);
	}

	init_stat = HAL_SUCCESS;
	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

/**
 * Secure Storage
 */
int ameba_hal_write_storage(uint32_t ss_idx, hal_data *data)
{
	AWRAP_ENTER;

	uint32_t ret;

	ret = rtl_write_storage_wrapper(ss_idx, data);

	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_read_storage(uint32_t ss_idx, hal_data *data)
{
	AWRAP_ENTER;

	uint32_t ret;
	
	ret = rtl_read_storage_wrapper(ss_idx, data);

	if (ret != HAL_SUCCESS) {
		sedbg("MbedTLS failed (%zu)\n", ret);
		return HAL_FAIL;
	}
	return HAL_SUCCESS;
}

int ameba_hal_delete_storage(uint32_t ss_idx)
{
	AWRAP_ENTER;

	rtl_delete_storage_wrapper(ss_idx);

	return HAL_SUCCESS;
}

static struct sec_ops_s g_ameba_ops = {
	ameba_hal_init,
	ameba_hal_deinit,
	ameba_hal_free_data,
	ameba_hal_get_status,
	ameba_hal_set_key,
	ameba_hal_get_key,
	ameba_hal_remove_key,
	ameba_hal_generate_key,
	ameba_hal_generate_random,
	ameba_hal_get_hash,
	ameba_hal_get_hmac,
	ameba_hal_rsa_sign_md,
	ameba_hal_rsa_verify_md,
	ameba_hal_ecdsa_sign_md,
	ameba_hal_ecdsa_verify_md,
	ameba_hal_dh_generate_param,
	ameba_hal_dh_compute_shared_secret,
	ameba_hal_ecdh_compute_shared_secret,
	ameba_hal_set_certificate,
	ameba_hal_get_certificate,
	ameba_hal_remove_certificate,
	ameba_hal_get_factory_key,
	ameba_hal_get_factory_cert,
	ameba_hal_get_factory_data,
	ameba_hal_aes_encrypt,
	ameba_hal_aes_decrypt,
	ameba_hal_rsa_encrypt,
	ameba_hal_rsa_decrypt,
	ameba_hal_write_storage,
	ameba_hal_read_storage,
	ameba_hal_delete_storage,
};

static struct sec_lowerhalf_s g_ameba_lower = {&g_ameba_ops, NULL};

#define SECLINK_PATH "/dev/seclink"

#ifndef LINUX
int se_initialize(void)
{
	int res = se_register(SECLINK_PATH, &g_ameba_lower);
	if (res != 0) {
		return -1;
	}

	return 0;
}
#endif

/*
 * It should not be used to general case.
 * It's for testing HAL APIs in user space.
 * Furthermore it wouldn't be used if binary separation is enabled.
 * Because user space couldn't access kernel space variable directly.
 * So it is protected by CONFIG after binary separation is applied.
 */
struct sec_lowerhalf_s *se_get_device(void)
{
	return &g_ameba_lower;
}
